{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Android ANR 问题分析","text":"参考文章ANRS - Android DevelopersANR 问题分析指北如何分析 ANR 的原因How to read Dalvik SIGQUIT output - elliotth’s blog通过Android trace文件分析死锁ANRDeadlocks and ANRsAndroid ANR Trace 详解","link":"/2018/04/10/Android_ANR_analysis/"},{"title":"Android自定义View之组合控件","text":"在项目开发中应用界面经常会使用一些布局相同但内容不同的界面，为了减少不必要的重复代码，首先想到的方案是写一个通用的 xml 布局文件，通过 include 标签复用布局，毫无疑问这种方式是可行的，但是由于显示内容的不同，需要在每个使用到的界面先获取到相关控件后再设置属性。通常我们只是想显示不同的文字或图标，不需要获取相关控件再设置属性，采用自定义组合控件可以轻松的实现布局复用，也可以减少代码的冗余量。 自定义组合控件的两种实现方式网上介绍自定义组合控件的文章很多，绝大部分文章都是介绍其中的一种实现方式，也有少部分文章虽然介绍了两种实现方式，但大都没有说两种实现方式有什么区别。下面我会介绍使用组合控件创建自定义 View 的两种实现方式，并通过运行示例来研究两种实现方式的区别，欢迎阅读并指出其中的错误。 为了便于区分将采用第一种方式实现的组合控件命名为 ItemView，采用第二种方式实现的组合控件命名为 ItemView2，请阅读文章时注意区分。 第一种方式在构造函数中通过 LayoutInflater.from(context).inflate(R.layout.xxx, this) 将布局与当前 View 进行绑定。 创建自定义组合控件ItemView.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package cn.neo.test;import android.content.Context;import android.support.annotation.Nullable;import android.util.AttributeSet;import android.util.Log;import android.view.LayoutInflater;import android.view.View;import android.widget.LinearLayout;public class ItemView extends LinearLayout { private static final String TAG = ItemView.class.getSimpleName(); public ItemView(Context context) { this(context, null); Log.i(TAG, \"[ItemView] \" + \"one param\"); } public ItemView(Context context, @Nullable AttributeSet attrs) { this(context, attrs, 0); Log.i(TAG, \"[ItemView] \" + \"two params\"); } public ItemView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); LayoutInflater.from(context).inflate(R.layout.item_view, this); } @Override protected void onFinishInflate() { super.onFinishInflate(); Log.i(TAG, \"[onFinishInflate] \" + TAG); } @Override public void onViewAdded(View child) { super.onViewAdded(child); Log.i(TAG, \"[onViewAdded] \" + child); } @Override public void onViewRemoved(View child) { super.onViewRemoved(child); Log.i(TAG, \"[onViewRemoved] \" + child); } @Override protected void onAttachedToWindow() { super.onAttachedToWindow(); Log.i(TAG, \"[onAttachedToWindow] \" + TAG); } @Override protected void onDetachedFromWindow() { super.onDetachedFromWindow(); Log.i(TAG, \"[onDetachedFromWindow] \" + TAG); }} item_view.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/ll_item_view\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:gravity=\"center_vertical\" android:orientation=\"horizontal\"&gt; &lt;ImageView android:id=\"@+id/iv_icon\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:src=\"@mipmap/ic_launcher\"/&gt; &lt;LinearLayout android:id=\"@+id/ll_content\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"16dp\" android:orientation=\"vertical\"&gt; &lt;TextView android:id=\"@+id/tv_title\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:maxLines=\"1\" android:text=\"@string/title1\" android:textColor=\"@color/colorPrimaryText\" android:textSize=\"14sp\"/&gt; &lt;TextView android:id=\"@+id/tv_summary\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" android:ellipsize=\"end\" android:maxLines=\"1\" android:text=\"@string/summary1\" android:textColor=\"@color/colorSecondaryText\" android:textSize=\"12sp\"/&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 创建好 ItemView 后，接下来看看通过不同方式使用 ItemView 的区别。 在布局中引用控件MainActivity.java12345678910111213package cn.neo.test;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); }} activity_main.xml123456789101112131415&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" tools:context=\"cn.neo.test.MainActivity\"&gt; &lt;cn.neo.test.ItemView android:id=\"@+id/item_view\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"/&gt;&lt;/LinearLayout&gt; 运行结果： 运行日志：123403-08 14:50:23.795 3371-3371/cn.neo.test I/ItemView: [onViewAdded] android.widget.LinearLayout{a73c472 V.E...... ......I. 0,0-0,0 #7f070046 app:id/ll_item_view}03-08 14:50:23.795 3371-3371/cn.neo.test I/ItemView: [ItemView] two params03-08 14:50:23.795 3371-3371/cn.neo.test I/ItemView: [onFinishInflate] ItemView03-08 14:50:23.847 3371-3371/cn.neo.test I/ItemView: [onAttachedToWindow] ItemView 在代码中新建控件MainActivity.java123456789101112131415161718package cn.neo.test;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.widget.FrameLayout;public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); FrameLayout container = findViewById(R.id.container); ItemView itemView = new ItemView(this); container.addView(itemView); }} activity_main.xml123456789101112131415&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" tools:context=\"cn.neo.test.MainActivity\"&gt; &lt;FrameLayout android:id=\"@+id/container\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"/&gt;&lt;/LinearLayout&gt; 运行结果： 运行日志：123403-08 14:53:03.422 3734-3734/cn.neo.test I/ItemView: [onViewAdded] android.widget.LinearLayout{a73c472 V.E...... ......I. 0,0-0,0 #7f070046 app:id/ll_item_view}03-08 14:53:03.422 3734-3734/cn.neo.test I/ItemView: [ItemView] two params03-08 14:53:03.422 3734-3734/cn.neo.test I/ItemView: [ItemView] one param03-08 14:53:03.456 3734-3734/cn.neo.test I/ItemView: [onAttachedToWindow] ItemView 从运行结果来看，以上两种方式都能正常显示出自定义 View。从运行日志中可以看到在布局中直接引用控件时，系统在添加完子 View 后会调用 onFinishInflate 方法；而通过 new 方式创建对象时系统不会执行 onFinishInflate 方法。因此在使用这种方式创建自定义组合控件时，不要在 onFinishInflate 方法中执行代码，因为使用 new 方式创建对象时系统根本不会执行该方法。 第二种方式将自定义 View 作为布局根节点使用，通过 inflate 方式创建自定义 View 的对象。 创建自定义组合控件ItemView2.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package cn.neo.test;import android.content.Context;import android.support.annotation.Nullable;import android.util.AttributeSet;import android.util.Log;import android.view.View;import android.widget.LinearLayout;public class ItemView2 extends LinearLayout { private static final String TAG = ItemView2.class.getSimpleName(); public ItemView2(Context context) { this(context, null); Log.i(TAG, \"[ItemView2] \" + \"one param\"); } public ItemView2(Context context, @Nullable AttributeSet attrs) { this(context, attrs, 0); Log.i(TAG, \"[ItemView2] \" + \"two params\"); } public ItemView2(Context context, @Nullable AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); } @Override public void onViewAdded(View child) { super.onViewAdded(child); Log.i(TAG, \"[onViewAdded] \" + child); } @Override public void onViewRemoved(View child) { super.onViewRemoved(child); Log.i(TAG, \"[onViewRemoved] \" + child); } @Override protected void onFinishInflate() { super.onFinishInflate(); Log.i(TAG, \"[onFinishInflate] \" + TAG); } @Override protected void onAttachedToWindow() { super.onAttachedToWindow(); Log.i(TAG, \"[onAttachedToWindow] \" + TAG); } @Override protected void onDetachedFromWindow() { super.onDetachedFromWindow(); Log.i(TAG, \"[onDetachedFromWindow] \" + TAG); }} item_view2.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;cn.neo.test.ItemView2 xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/ll_item_view2\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:gravity=\"center_vertical\" android:orientation=\"horizontal\"&gt; &lt;ImageView android:id=\"@+id/iv_icon2\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:src=\"@mipmap/ic_launcher\"/&gt; &lt;LinearLayout android:id=\"@+id/ll_content2\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"16dp\" android:orientation=\"vertical\"&gt; &lt;TextView android:id=\"@+id/tv_title2\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:maxLines=\"1\" android:text=\"@string/title2\" android:textColor=\"@color/colorPrimaryText\" android:textSize=\"14sp\"/&gt; &lt;TextView android:id=\"@+id/tv_summary2\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" android:ellipsize=\"end\" android:maxLines=\"1\" android:text=\"@string/summary2\" android:textColor=\"@color/colorSecondaryText\" android:textSize=\"12sp\"/&gt; &lt;/LinearLayout&gt;&lt;/cn.neo.test.ItemView2&gt; 在创建好 ItemView2 后，同样先来看看通过不同方式使用 ItemView2 的区别。 在布局中引用控件MainActivity.java12345678910111213package cn.neo.test;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); }} activity_main.xml123456789101112131415&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" tools:context=\"cn.neo.test.MainActivity\"&gt; &lt;cn.neo.test.ItemView2 android:id=\"@+id/item_view2\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"/&gt;&lt;/LinearLayout&gt; 运行结果： 运行日志：12303-08 15:07:15.789 1551-1551/? I/ItemView2: [ItemView2] two params03-08 15:07:15.789 1551-1551/? I/ItemView2: [onFinishInflate] ItemView203-08 15:07:15.821 1551-1551/? I/ItemView2: [onAttachedToWindow] ItemView2 可以看到界面上没有显示任何控件，ItemView2 没有被显示出来。 在代码中新建控件activity_main.xml123456789101112131415&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" tools:context=\"cn.neo.test.MainActivity\"&gt; &lt;FrameLayout android:id=\"@+id/container\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"/&gt;&lt;/LinearLayout&gt; 使用 new 的方式新建控件对象MainActivity.java123456789101112131415161718package cn.neo.test;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.widget.FrameLayout;public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); FrameLayout container = findViewById(R.id.container); ItemView2 itemView2 = new ItemView2(this); container.addView(itemView2); }} 运行日志：12303-08 15:14:01.098 3145-3145/cn.neo.test I/ItemView2: [ItemView2] two params03-08 15:14:01.098 3145-3145/cn.neo.test I/ItemView2: [ItemView2] one param03-08 15:14:01.171 3145-3145/cn.neo.test I/ItemView2: [onAttachedToWindow] ItemView2 运行代码可以看到界面上也没有显示任何控件，这里就不展示运行结果了，请自行尝试查看效果。 使用 inflate 的方式新建控件对象MainActivity.java1234567891011121314151617181920package cn.neo.test;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.LayoutInflater;import android.widget.FrameLayout;public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); FrameLayout container = findViewById(R.id.container); ItemView2 itemView2 = (ItemView2) LayoutInflater.from(this) .inflate(R.layout.item_view2, null); container.addView(itemView2); }} 运行结果： 运行日志：1234503-08 15:38:14.075 4482-4482/cn.neo.test I/ItemView2: [ItemView2] two params03-08 15:38:14.083 4482-4482/cn.neo.test I/ItemView2: [onViewAdded] android.support.v7.widget.AppCompatImageView{f93c804 V.ED..... ......ID 0,0-0,0 #7f07003f app:id/iv_icon2}03-08 15:38:14.097 4482-4482/cn.neo.test I/ItemView2: [onViewAdded] android.widget.LinearLayout{8538822 V.E...... ......I. 0,0-0,0 #7f070045 app:id/ll_content2}03-08 15:38:14.097 4482-4482/cn.neo.test I/ItemView2: [onFinishInflate] ItemView203-08 15:38:14.172 4482-4482/cn.neo.test I/ItemView2: [onAttachedToWindow] ItemView2 从日志信息可以看到两个注意点： 通过 inflate 创建对象时调用的是两个参数的构造函数。 xml 布局中所有子 View 都被添加成功后，系统会调用 onFinishInflate() 方法通知绘制完毕。 第一点解释了为什么使用组合控件创建自定义 View 时必须需要重写两个参数的构造函数。第二点可以看到如果想要在自定义 View 中做一些初始化设置，使用 findViewById() 获取对象的操作必须放在 super.onFinishInflate() 调用之后，否则获取对象设置属性时会报 NullPointerException 异常，有兴趣可自行尝试在 super.onFinishInflate() 之前获取对象设置属性，查看运行结果是否如上所述。 分析使用第一种方式创建自定义组合控件时，可以在布局中直接引用控件，也可以在代码中通过 new 的方式新建控件的对象。如果使用第二种方式创建自定义组合控件，那么既无法在布局中直接引用控件，也不能通过 new 的方式新建对象，只能使用 inflate 新建控件的对象，然后才可以使用控件，否则控件在界面上不会显示出来。 从两种不同创建方式的使用区别来看，使用组合控件创建自定义 View 的关键在于如何将布局填充到 ViewGroup 中。第一种方式在创建 View 时直接在构造函数中将布局填充到当前 ViewGroup 中，所以可以直接在布局中引用控件，也可以直接 new 控件的对象。而第二种方式在创建自 View 时没有与布局直接关联，所以只能通过 inflate 将布局与自定义 View 绑定后再使用。 以上就是两种不同方式创建自定义组合控件的使用差别，从上面的示例可以看出第一种方式比第二种方式使用起来更加便捷。另外当需要给组合控件添加一些通用属性时，使用第一种方式创建的组合控件使用起来更加便捷。因此我个人推荐使用组合控件创建自定义 View 时使用第一种方法，第二种方法作为了解即可。 完整示例ItemView.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package cn.neo.test;import android.content.Context;import android.content.res.TypedArray;import android.graphics.drawable.Drawable;import android.support.annotation.LayoutRes;import android.support.annotation.Nullable;import android.support.annotation.StringRes;import android.util.AttributeSet;import android.view.LayoutInflater;import android.widget.ImageView;import android.widget.LinearLayout;import android.widget.TextView;public class ItemView extends LinearLayout { private static final String TAG = ItemView.class.getSimpleName(); private Drawable mItemIcon; private CharSequence mItemTitle; private CharSequence mItemSummary; private ImageView mIconIv; private TextView mTitleTv; private TextView mSummaryTv; public ItemView(Context context) { this(context, null); } public ItemView(Context context, @Nullable AttributeSet attrs) { this(context, attrs, 0); } public ItemView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); initView(context, attrs); } private void initView(Context context, AttributeSet attrs) { TypedArray array = context.obtainStyledAttributes(attrs, R.styleable.ItemView); mItemIcon = array.getDrawable(R.styleable.ItemView_itemIcon); mItemTitle = array.getString(R.styleable.ItemView_itemTitle); mItemSummary = array.getString(R.styleable.ItemView_itemSummary); array.recycle(); LayoutInflater.from(context).inflate(R.layout.item_view, this); mIconIv = findViewById(R.id.iv_icon); mTitleTv = findViewById(R.id.tv_title); mSummaryTv = findViewById(R.id.tv_summary); mIconIv.setImageDrawable(mItemIcon); mTitleTv.setText(mItemTitle); mSummaryTv.setText(mItemSummary); } @Override protected void onAttachedToWindow() { super.onAttachedToWindow(); // register listener ... } @Override protected void onDetachedFromWindow() { super.onDetachedFromWindow(); // unregister listener ... } public void setIcon(Drawable icon) { mIconIv.setImageDrawable(icon); } public Drawable getIcon() { return mItemIcon; } public void setTitle(@StringRes int resId) { setTitle(getResources().getString(resId)); } public void setTitle(CharSequence title) { mItemTitle = title; mTitleTv.setText(title); } public CharSequence getTitle() { return mItemTitle; } public void setSummary(@StringRes int resId) { setSummary(getResources().getString(resId)); } public void setSummary(CharSequence summary) { mItemSummary = summary; mSummaryTv.setText(summary); } public CharSequence getSummary() { return mItemSummary; }} item_view.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/ll_item_view\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:gravity=\"center_vertical\" android:orientation=\"horizontal\"&gt; &lt;ImageView android:id=\"@+id/iv_icon\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:src=\"@mipmap/ic_launcher\" /&gt; &lt;LinearLayout android:id=\"@+id/ll_content\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"16dp\" android:orientation=\"vertical\"&gt; &lt;TextView android:id=\"@+id/tv_title\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:maxLines=\"1\" android:text=\"@string/title1\" android:textColor=\"@color/colorPrimaryText\" android:textSize=\"14sp\" /&gt; &lt;TextView android:id=\"@+id/tv_summary\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" android:ellipsize=\"end\" android:maxLines=\"1\" android:text=\"@string/summary1\" android:textColor=\"@color/colorSecondaryText\" android:textSize=\"12sp\" /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; attrs.xml12345678&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;declare-styleable name=\"ItemView\"&gt; &lt;attr name=\"itemIcon\" format=\"reference\" /&gt; &lt;attr name=\"itemTitle\" format=\"string\" /&gt; &lt;attr name=\"itemSummary\" format=\"string\" /&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; MainActivity.java123456789101112131415161718192021package cn.neo.test;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.widget.FrameLayout;public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); FrameLayout container = findViewById(R.id.container); ItemView itemView = new ItemView(this); itemView.setIcon(getResources().getDrawable(R.mipmap.ic_launcher_round)); itemView.setTitle(R.string.test_title2); itemView.setSummary(R.string.test_summary2); container.addView(itemView); }} activity_main.xml1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" tools:context=\"cn.neo.test.MainActivity\"&gt; &lt;cn.neo.test.ItemView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:itemIcon=\"@mipmap/ic_launcher_round\" app:itemSummary=\"@string/test_summary1\" app:itemTitle=\"@string/test_title1\" /&gt; &lt;View android:layout_width=\"match_parent\" android:layout_height=\"3px\" android:layout_marginBottom=\"8dp\" android:layout_marginTop=\"8dp\" android:background=\"@color/colorPrimary\" /&gt; &lt;FrameLayout android:id=\"@+id/container\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /&gt;&lt;/LinearLayout&gt; 从上面的完整示例可以看到，使用第一种方式创建组合控件自定义 View 时，无论使用哪种方法引用控件都可以很方便的设置相关属性，下面是完整示例的运行结果： 参考文章onFinishInflate() never gets called - stackoverflow","link":"/2018/03/06/Android%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8B%E7%BB%84%E5%90%88%E6%8E%A7%E4%BB%B6/"},{"title":"Android 内存分析","text":"参考文章Android内存分析命令 - Gityuan调查 RAM 使用情况","link":"/2018/05/10/android-memory-analysis/"},{"title":"Java Nested Classes - Java嵌套类","text":"本文节选了 Nested Classes 官方文档的部分内容进行翻译，通过翻译过程系统地学习 Java 嵌套类。 Nested Classes - 嵌套类Java 编程语言允许在一个类中定义另一个类，这样的类被称为嵌套类：123456class OuterClass { ... class NestedClass { ... }} 嵌套类分为两种：static（静态） 和 non-static (非静态)。声明为 static 的嵌套类称为静态嵌套类（static nested classes），非静态嵌套类称为内部类（inner classes）。123456789static OuterClass { ... static class StaticNestedClass { ... } class InnerClass { ... }} 嵌套类是封闭类的一个成员。非静态嵌套类可以访问封闭类的其它成员，即使它们被声明为 private。静态嵌套类无法访问封闭类的其它成员。作为外部类的一个成员，嵌套类可以声明为private、 public、protected 或 package private，回想一下外部类只能声明为 public 或者 package private。 什么是 package private？如果一个类没有使用 private、 public 或者 protected 修饰，那么这个类具有 Java 提供的一种默认访问权限，这种权限通常称为包访问权限。在这种权限下，类可以访问在同一个包中的其它类的成员，但是在包之外，这些成员如同指定了 private 一样。 为何使用嵌套类有以下几条令人信服的理由使用嵌套类： 它是一种将只在一个地方使用的类进行逻辑分组的方式 增强了封装性 可以使代码具有更好的可读性和可维护性 Static Nested Classes - 静态嵌套类与类方法和变量一样，静态嵌套类与外部类相关联。与静态方法一样，静态嵌套类不能直接引用封闭类中定义的实例变量或方法，只能通过一个对象引用来使用它们。静态嵌套类与它外部类实例成员或方法(和其它类)之间的交互就像任何其它顶级类一样。实际上，为了方便打包，静态嵌套类在行为上是嵌套在另一个顶级类中的顶级类。通俗的理解就是：静态嵌套类只是为了打包方便而将一个类隐藏在另一个类中，和外部类之间不存在本质上的“内外”关系。 静态嵌套类的调用方式如下：12345// 访问方式OuterClass.StaticNestedClass// 实例：创建一个新的静态嵌套类对象OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass(); Inner Classes - 内部类与实例方法和变量一样，一个内部类与包含它的外部类实例相关联，可以直接访问外部类实例的方法和字段。此外，因为内部类与实例相关联，所以内部类本身不能定义任何静态成员。 一个内部类的实例只能存在于一个外部类的实例中，并且可以直接访问外部类实例的方法和字段。想要实例化一个内部类，必须先实例化外部类，然后再通过外部类对象创建内部类的实例，语法如下：12OuterClass outerClass = new OuterClass();OuterClass.InnerClass innerClass = outerClass.new InnerClass(); 有两种特殊的内部类：局部类 local classes 和 匿名类 anonymous classes。 遮盖如果特定作用域（如内部类或方法定义）中的类型声明（例如成员变量或参数名称）与封闭作用域中的另一个声明具有相同的名称，则该声明会隐藏封闭范围中的声明。你无法单独通过名称来引用被隐藏的声明。下面的示例 ShadowTest 演示了这一点：123456789101112131415161718192021public class ShadowTest { public int x = 0; class FirstLevel { public int x = 1; void methodInFirstLevel(int x) { System.out.println(\"x = \" + x); System.out.println(\"this.x = \" + this.x); System.out.println(\"ShadowTest.this.x = \" + ShadowTest.this.x); } } public static void main(String... args) { ShadowTest st = new ShadowTest(); ShadowTest.FirstLevel fl = st.new FirstLevel(); fl.methodInFirstLevel(23); }} 示例输出如下：123x = 23this.x = 1ShadowTest.this.x = 0 这个例子定义了三个名为x的变量：ShadowTest 类的成员变量，内部类 FirstLevel 的成员变量，以及 methodInFirstLevel 方法的参数。methodInFirstLevel 方法定义的参数x遮盖了内部类 FirstLevel 的变量x。因此在方法 methodInFirstLevel 中使用变量x时，它指向的是方法参数。要引用内部类 FirstLevel 的成员变量x，请使用关键字 this 来表示封闭范围：1System.out.println(\"this.x = \" + this.x); 通过它们所属的类名引用包含较大范围的成员变量。例如下面的语句在 methodInFirstLevel 方法中访问了类 ShadowTest 的成员变量x：1System.out.println(\"ShadowTest.this.x = \" + ShadowTest.this.x); 序列化序列化内部类，包括局部类和匿名类是强烈不建议的。当 Java 编译器编译某些结构（如内部类）时，它会创建合成结构，这些是在源代码中没有相应构造的类，方法，字段和其他构造。合成结构使 Java 编译器能够在不改变 JVM 的情况下实现新的 Java 语言功能。但是合成结构在不同的 Java 编译器实现中可能会有所不同，这意味着.class文件在不同的实现中也会有所不同。因此如果序列化内部类，然后使用不同的 JRE 实现对其进行反序列化，则可能会遇到兼容性问题。 Local Classes - 局部类局部类是定义在一个块中的类，是一组大括号之间的零个或多个语句，通常你会发现局部类定义在一个方法的区块里。 定义局部类你可以在任何区块中定义局部类。例如：你可以在方法体、for循环或者 if语句中定义局部类。 下面的 LocalClassExample 示例用来校验两个电话号码，它在 validatePhoneNumber 方法中定义了局部类 PhoneNumber：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class LocalClassExample { static String regularExpression = \"[^0-9]\"; public static void validatePhoneNumber(String phoneNumber1, String phoneNumber2) { final int numberLength = 10; class PhoneNumber { String formattedPhoneNumber = null; PhoneNumber(String phoneNumber) { String currentNumber = phoneNumber.replaceAll(regularExpression, \"\"); if (currentNumber.length() == numberLength) { formattedPhoneNumber = currentNumber; } else { formattedPhoneNumber = null; } } public String getPhoneNumber() { return formattedPhoneNumber; } // Valid in JDK 8 or later public void printOriginalNumbers() { System.out.println(\"Original numbers are \" + phoneNumber1 + \" and \" + phoneNumber2); } } PhoneNumber myNumber1 = new PhoneNumber(phoneNumber1); PhoneNumber myNumber2 = new PhoneNumber(phoneNumber2); if (myNumber1.getPhoneNumber() == null) { System.out.println(\"First number is invalid\"); } else { System.out.println(\"First number is \" + myNumber1.getPhoneNumber()); } if (myNumber2.getPhoneNumber() == null) { System.out.println(\"Second number is invalid\"); } else { System.out.println(\"Second number is \" + myNumber2.getPhoneNumber()); } } public static void main(String... args) { validatePhoneNumber(\"123-456-7890\", \"456-7890\"); }} 上面的示例运行结果如下：12First number is 1234567890Second number is invalid 访问封闭类的成员局部类可以访问外部类的成员。在上面的示例中， PhoneNumber 的构造函数访问了成员 LocalClassExample.regularExpression。 此外局部类可以访问局部变量，但是局部类只能访问声明为 final 的局部变量。当局部类访问封闭区块的本地变量或参数的时候，它捕获了那个变量或参数。例如，PhoneNumber 的构造函数可以访问本地变量 numberLength 是因为它被声明为 final，此时 numberLength 是一个捕获变量。 然而从Java SE 8开始，局部类可以访问封闭区块final 或者 effectively final 的局部变量或参数。一个变量或者参数初始化后值不再改变称为 effectively final。 例如：假设变量 numberLength 没有被定义为 final，而是在 PhoneNumber 的构造函数中初始化 numberLength 的值为7： 12345PhoneNumber(String phoneNumber) { numberLength = 7; String currentNumber = phoneNumber.replaceAll(regularExpression, \"\"); ......} 因为赋值语句，变量 numberLength 不再 effectively final。因此 Java 编译器会在 PhoneNumber 访问变量 numberLength 的地方生成错误信息 “local variables referenced from an inner class must be final or effectively final”：1if (currentNumber.length() == numberLength) 从Java SE 8开始，如果在方法中定义局部类，局部类可以访问方法的参数:1234public void printOriginalNumbers() { System.out.println(\"Original numbers are \" + phoneNumber1 + \" and \" + phoneNumber2);} 局部类与内部类相似局部类与内部类相似，因为它们无法定义或声明任何静态成员。静态方法中的局部类只能引用封闭类的静态成员，就像定义在静态方法 validatePhoneNumber 中的 PhoneNumber 类。如果你没有将成员变量 regularExpression 定义为 static，那么 Java 编译器就会生成错误信息 “non-static variable regularExpression cannot be referenced from a static context”。 局部类由于是非静态的，所以它们可以访问封闭区块的实例变量，因此它们不能包含绝大部分的静态声明。 你不能在一个区块中定义接口，因为接口在本质上是静态的。下面的代码无法编译通过，因为在 greetInEnglish 方法中定义了接口 HelloThere ：123456789101112public void greetInEnglish() { interface HelloThere { public void greet(); } class EnglishHelloThere implements HelloThere { public void greet() { System.out.println(\"Hello \" + name); } } HelloThere myGreeting = new EnglishHelloThere(); myGreeting.greet();} 你不能在局部类中声明静态初始化器或成员接口。下面的代码无法编译通过，因为方法 EnglishGoodbye.sayGoodbye 被定义为 static。当编译器遇到这个方法时会生成错误信息 “modifier ‘static’ is only allowed in constant variable declaration”：12345678public void sayGoodbyeInEnglish() { class EnglishGoodbye { public static void sayGoodbye() { System.out.println(\"Bye bye\"); } } EnglishGoodbye.sayGoodbye();} 局部类可以包含常量静态成员。常量是一个定义为final 的基本数据类型或String类型的变量，通过编译时常量表达式进行初始化。编译时常量表达式通常是一个字符串或一个可以在编译时评估出值的算数表达式。下面的代码可以编译通过，因为静态成员 EnglishGoodbye.farewell 是一个常量：12345678910public void sayGoodbyeInEnglish() { class EnglishGoodbye { public static final String farewell = \"Bye bye\"; public void sayGoodbye() { System.out.println(farewell); } } EnglishGoodbye myEnglishGoodbye = new EnglishGoodbye(); myEnglishGoodbye.sayGoodbye();} Anonymous Classes - 匿名类匿名类可以让代码更简洁，匿名类允许在同一时间声明和实例化一个类。除了没有类名之外，匿名类跟局部类很像。如果你只需要使用局部类一次，那么推荐你使用匿名类。 定义匿名类局部类是类声明，而匿名类是表达式，这意味着你在其它表达式里面定义了一个类。下面的 HelloWorldAnonymousClasses 示例在初始化本地变量frenchGreeting 和 spanishGreeting 使用了匿名类，而在初始化变量 englishGreeting 使用了本地类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class HelloWorldAnonymousClasses { interface HelloWorld { public void greet(); public void greetSomeone(String someone); } public void sayHello() { class EnglishGreeting implements HelloWorld { String name = \"world\"; public void greet() { greetSomeone(\"world\"); } public void greetSomeone(String someone) { name = someone; System.out.println(\"Hello \" + name); } } HelloWorld englishGreeting = new EnglishGreeting(); HelloWorld frenchGreeting = new HelloWorld() { String name = \"tout le monde\"; public void greet() { greetSomeone(\"tout le monde\"); } public void greetSomeone(String someone) { name = someone; System.out.println(\"Salut \" + name); } }; HelloWorld spanishGreeting = new HelloWorld() { String name = \"mundo\"; public void greet() { greetSomeone(\"mundo\"); } public void greetSomeone(String someone) { name = someone; System.out.println(\"Hola, \" + name); } }; englishGreeting.greet(); frenchGreeting.greetSomeone(\"Fred\"); spanishGreeting.greet(); } public static void main(String... args) { HelloWorldAnonymousClasses myApp = new HelloWorldAnonymousClasses(); myApp.sayHello(); }} 匿名类的语法如前所述，匿名类是一个表达式。匿名类表达式的语法就像一个构造函数的调用，除了在代码中包含一块类定义的区域。 思考一下 frenchGreeting 对象的初始化：12345678910HelloWorld frenchGreeting = new HelloWorld() { String name = \"tout le monde\"; public void greet() { greetSomeone(\"tout le monde\"); } public void greetSomeone(String someone) { name = someone; System.out.println(\"Salut \" + name); }}; 匿名类的语法由如下组成： 新的操作者 用于实现的接口或者继承的类的名称。在这个示例中，匿名类实现了接口 HelloWorld。 一个包含构造函数参数的括号，就像一个正常类创建实例的表达式。注意：当你实现接口的时候，接口没有构造函数，所以需要像这个例子一样使用一对大括号。 一块用来定义类的区域。更具体的说，在该区域内可以定义方法但是不能声明方法。(定义方法和声明方法的区别请阅读参考文章2) 因为匿名类定义是一个表达式，所以它必须是声明的一部分。在这个例子中，匿名类表达式是实例化 frenchGreeting 对象声明的一部分，这解释了为什么大括号后面有一个分号。 访问封闭范围的局部变量，声明和访问匿名类的成员匿名类可以像局部类一样捕获变量，它们对封闭范围的局部变量有同样的访问权限： 匿名类可以访问封闭类的成员 匿名类不能访问封闭范围内未声明为 final 或 effectively final 的局部变量 像嵌套类一样，匿名类的类型声明（例如变量）会隐藏包含范围中具有相同名称的其它任何声明。 匿名类和局部类对于它们的成员有同样的限制： 你不能在一个匿名类中声明静态初始化器或成员接口 匿名类可以拥有静态常量成员 注意你可以在匿名类中声明下面的东西： 字段 额外的方法（即使它们没有实现超类的任何方法） 实例初始值设定项 局部类 但是你不能在匿名类中声明构造函数。 参考文章1. Nested Classes - Java Documentation2. What is the difference between declaration and definition in Java? - StackOverflow","link":"/2018/03/21/Java-Nested-Classes-Java%E5%B5%8C%E5%A5%97%E7%B1%BB/"},{"title":"Android Service 生命周期","text":"Service 有两种启动方式：Context.startService() 和 Context.bindService()。 启动服务的两种方式Context.startService()Context.bindService()参看文章Service - Android Developer服务 - Android Developer","link":"/2018/08/27/android-service/"},{"title":"Markdown 常用语法","text":"本文用于记录 Markdown 的语法。 TODO添加页内跳转（锚点链接）如果一篇文章很长，没有目录会导致阅读起来很不方便，添加页内跳转（也叫锚点链接）可以解决这个问题。 创建锚点有几种创建锚点的方式，使用哪种方式都可以，只是在显示上可能有些差别：1234[create an anchor](#anchors-in-markdown)&lt;a id=&quot;anchors-in-markdown&quot;&gt;create an anchor&lt;/a&gt;&lt;div id=&quot;anchors-in-markdown&quot;&gt;create an anchor&lt;/div&gt;&lt;span id=&quot;anchors-in-markdown&quot;&gt;create an anchor&lt;/span&gt; 这个 anchors-in-markdown 通俗的理解就是一个 key，跳转锚点时就是根据这个 key 来找到对应锚点的，因此这个值必须是唯一的。这个值可以是中文，但必须保证唯一性。通常我们一般都是在章节标题这些地方使用锚点，目的是方便用户快速查看某个章节的内容。 比如：我想给上面的 “添加页内跳转（锚点链接）” 这个章节创建一个锚点，那么可以这样写：1234[添加页内跳转（锚点链接）](#add_anchor_in_page)&lt;a id=&quot;add_anchor_in_page&quot;&gt;添加页内跳转（锚点链接）&lt;/a&gt;&lt;div id=&quot;add_anchor_in_page&quot;&gt;添加页内跳转（锚点链接）&lt;/div&gt;&lt;span id=&quot;add_anchor_in_page&quot;&gt;添加页内跳转（锚点链接）&lt;/span&gt; 访问锚点访问锚点的方式都是一样的：1[visit an anchor](#anchors-in-markdown) 比如我想访问 “添加页内跳转（锚点链接）” 这个锚点，那么就需要这么写：1[跳转到 “添加页内跳转（锚点链接）”](#add_anchor_in_page) [] 中的描述内容可以随意写，只要在 # 后面添加想要访问的锚点名称就行了。 演示锚点首先创建四个标题： 标题1标题2标题3标题4点击文字跳转到锚点：点击 我是标题1的锚点 跳转到“标题1”小章节。点击 我是标题2的锚点 跳转到“标题2”小章节。点击 我是标题3的锚点 跳转到“标题3”小章节。点击 我是标题4的锚点 跳转到“标题4”小章节。 因为只是演示，所以不会看到明显的界面跳转。在实际使用时，如果锚点和访问点已经无法在电脑屏幕上同时显示，那么点击访问点可以看到页面会自动跳转锚点那。 差别从此页面 hexo 支持的博客渲染效果来看，[create an anchor](#anchors-in-markdown) 和 使用 a 标签创建的锚点，会在锚点的描述文字底部显示一条线 —，表示这是个链接。而使用 div 和 span 标签创建的锚点不会显示链接的标志。","link":"/2018/05/25/markdown-grammar/"},{"title":"Android xliff 介绍","text":"标记字符串中不需要翻译的文字Android 系统通过在字符串中添加 xliff:g 占位符来标记字符串中不需要翻译的文字，使用 xliff:g 占位符需要在 resources 节点添加相应的 xmlns：1xmlns:xliff=\"urn:oasis:names:tc:xliff:document:1.2\" 使用方法strings.xml1&lt;xliff:g example=\"xxx\" id=\"xxx\"&gt;format_specifiers&lt;/xliff:g&gt; example： 如果程序在运行时会替换占位符的内容，最好提供此属性来明确预期使用结果 id： 解释占位符的作用 format_specifiers： 格式说明符，用来指定文字的输出格式 代码通过 Resources.getString(@StringRes int id, Object… formatArgs) 方法动态加载字符串的内容，formatArgs 根据参数下标替代对应占位符中的内容。 格式说明符语法1%[argument_index$][flags][width][.precision]conversion 可选参数 argument_index 是一个十进制整数，表示参数在参数列表中的位置。第一个参数下标是 1$，第二个参数下标是 2$，依此类推。 可选参数 flags 是一组字符，用来修改输出格式。有效转换集取决于 conversion。 可选参数 width 是一个十进制正整数，表示输出结果的最小字符数。 可选参数 precision 是一个非负十进制整数，通常用来限制字符数。输出结果取决于 conversion。 必要参数 conversion 是一个字符，用来表示参数如何被格式化。给定参数的有效转换集取决于参数的数据类型。 查看源码可以知道 Resources.getString(@StringRes int id, Object… formatArgs) 实际上调用的是 String.format(…) 方法：123456@NonNullpublic String getString(@StringRes int id, Object... formatArgs) throws NotFoundException { final String raw = getString(id); return String.format(mResourcesImpl.getConfiguration().getLocales().get(0), raw, formatArgs);} 因此字符串如何格式化实际上就是 String.format() 如何格式化。关于如何 String.format() 如何格式化字符串请参考 Java String Format Examples 或者 JAVA字符串格式化-String.format()的使用，文章里面有详细的介绍和示例。 示例字符串资源只有一个占位符字符串只有一个占位符时，1$ 下标可以不写：12345&lt;resources xmlns:xliff=\"urn:oasis:names:tc:xliff:document:1.2\"&gt; &lt;string name=\"app_name\"&gt;Test&lt;/string&gt; &lt;string name=\"name_introduction\"&gt;My name is &lt;xliff:g example=\"jack\" id=\"name\"&gt;%s&lt;/xliff:g&gt;.&lt;/string&gt; &lt;string name=\"age_introduction\"&gt;I am &lt;xliff:g example=\"20\" id=\"age\"&gt;%d&lt;/xliff:g&gt; years old.&lt;/string&gt;&lt;/resources&gt; 在代码中动态加载字符串：1234String name = getResources().getString(R.string.name_introduction, \"alex\");System.out.println(name);String age = getResources().getString(R.string.age_introduction, 20);System.out.println(age); 查看输出结果：1208-30 17:28:27.655 6628-6628/cn.neo.test I/System.out: My name is alex.08-30 17:28:27.655 6628-6628/cn.neo.test I/System.out: I am 20 years old. 字符串资源有多个占位符当字符串包含多个占位符时，需要指定每个参数的下标：1&lt;string name=\"self_introduction\"&gt;My name is &lt;xliff:g example=\"jack\" id=\"name\"&gt;%1$s&lt;/xliff:g&gt; and I am &lt;xliff:g example=\"20\" id=\"age\"&gt;%2$d&lt;/xliff:g&gt; years old.&lt;/string&gt; 12String selfInfo = getResources().getString(R.string.self_introduction, \"alex\", 20);System.out.println(selfInfo); 108-30 17:35:20.379 7923-7923/cn.neo.test I/System.out: My name is alex and I am 20 years old. 参考文章Formatter - Android DeveloperReferring to resources in code - Android DeveloperWhat does “xmlns” in XML mean? - Stack OverflowXLIFF - WikipediaJava String Format ExamplesJAVA字符串格式化-String.format()的使用","link":"/2018/08/29/xliff-in-android-string-resources/"},{"title":"Git常用命令总结","text":"首先建议大家阅读 官方文档，里面详细的介绍了 Git 的前世今生。官方文档基本提供了你需要的任何跟 Git 相关的东西，并且文档非常友好地提供了中文版。 既然官方文档有中文版了，为什么还要写这篇文章呢？我的目的当然不是为了重复造轮子，主要是用来记录一些平时开发常用的命令，养成良好的总结和记录习惯对我们很有帮助，希望大家也能养成这个习惯。 安装和配置 Git安装 Git 请参照 安装 Git，配置 Git 请参照 初次运行 Git 前的配置。 查看配置信息1git config --list 配置单个项目的用户名和邮箱有时我们想在当前项目中使用特定的用户名和邮箱，只要去掉 --global 选项或者使用 --local 选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里：12git config [--local] user.name &quot;local.name&quot;git config [--local] user.email &quot;local.email&quot;查看配置信息可以看到末尾新增了刚才设置的用户名和邮箱。 想要撤销单个项目配置的用户名和邮箱也很简单，只需要使用下面的命令即可：12git config --unset user.namegit config --unset user.email再次查看配置信息，可以看到本地配置的用户名和邮箱已经被删除了，提交代码时会默认使用全局配置的用户名和邮箱。 格式化与空白字符格式化和空白问题是许多开发人员在协作时遇到的一些更令人沮丧和微妙的问题，特别是跨平台问题。因为编辑器的原因，修补程序或其他协作工作很容易引入细微的空白变化，如果你的文件曾经触摸过 Windows 系统，那么它们的行尾可能会被替换掉。Git 提供了几个配置选项来帮助解决这些问题。 core.autocrlf假如你正在 Windows 上写程序，而你的同伴用的是其他系统（或相反），你可能会遇到 CRLF 问题。 这是因为 Windows 使用回车（CR）和换行（LF）两个字符来结束一行，而 Mac 和 Linux 只使用换行（LF）一个字符。虽然这是小问题，但它会极大地扰乱跨平台协作。许多 Windows 上的编辑器会悄悄把行尾的换行字符转换成回车和换行，或在用户按下 Enter 键时，插入回车和换行两个字符。 Git 可以在提交时自动地把回车和换行转换成换行，而在检出代码时把换行转换成回车和换行。你可以用 core.autocrlf 来打开此项功能。如果是在 Windows 系统上，把它设置成 true，这样在检出代码时，换行会被转换成回车和换行：1git config --global core.autocrlf true 如果使用以换行作为行结束符的 Linux 或 Mac，你不需要 Git 在检出文件时进行自动的转换；然而当一个以回车加换行作为行结束符的文件不小心被引入时，你肯定想让 Git 修正。 你可以把 core.autocrlf 设置成 input 来告诉 Git 在提交时把回车和换行转换成换行，检出时不转换：1git config --global core.autocrlf input这样在 Windows 上的检出文件中会保留回车和换行，而在 Mac 和 Linux 上，以及版本库中会保留换行。 如果你是 Windows 程序员，且正在开发仅运行在 Windows 上的项目，可以设置 false 取消此功能，把回车保留在版本库中：1git config --global core.autocrlf false LF 关于 Git 配置的更多介绍请参考 配置 Git。 获取帮助的三种方式可以通过以下三种方法可以找到 Git 命令的使用手册：123git help &lt;verb&gt;git &lt;verb&gt; --helpman git-&lt;verb&gt; 例如查看 config 命令的手册，执行：1git help config Git 的三种状态在正式使用 Git 之前，需要了解 Git 中几个非常重要的概念。 Git 基础 写到 “Git 有三种状态，你的文件可能处于其中之一：已提交 committed、已修改 modified 和已暂存staged”。实际上这段描述翻译地不是特别准确，英文原文是 “Git has three main states that your files can reside in: committed, modified, and staged“。原文实际上说的是 “你的文件在 Git 主要有三种状态：已提交 committed、已修改 modified 和已暂存 staged”，意思是主要有三种状态，而不是只有三种状态的意思。因为这可能给后面 Git 文件状态变化的理解造成误导，所以特地指出。 committed 表示数据已经安全的保存在本地数据库中。modified 表示修改了文件，但还没保存到数据库中。staged 表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。 由此引入 Git 项目的三个工作区域的概念：Git 仓库、工作目录以及暂存区域。 Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。 工作目录是对项目的某个版本独立提取出来的内容。这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。 暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。有时候也被称作‘索引’，不过一般说法还是叫暂存区域。 基本的 Git 工作流程如下： 在工作目录中修改文件。 暂存文件，将文件的快照放入暂存区域。 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。 如果 Git 目录中保存着特定的版本文件，就属于已提交状态。如果作了修改并已放入暂存区域，就属于已暂存状态。如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态。 工作目录下的每一个文件都不外乎两种状态：已跟踪或未跟踪。已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区。初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。下图是 Git 中文件的状态变化周期： 在使用 Git 命令时，需要牢记文件状态以及工作区域的概念。 获取 Git 仓库创建一个新的仓库1git init 克隆现有的仓库1git clone url [local-repo-name] 不指定本地仓库 local-repo-name 名称时，系统会默认创建与远程仓库名称相同的文件夹并将仓库拷贝到文件夹中。 记录每次更新到仓库1.查看当前文件的状态1git status 2.跟踪新文件1git add filename也可以使用 git commit -A 命令将所有文件添加到暂存区域。 3.查看修改1git diff [--cached] [filename]git diff 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。如果不指定文件名称，默认会比较本地所有已跟踪但未暂存的修改。 若要查看已暂存的将要添加到下次提交里的内容，可以用 git diff --cached 命令。（Git 1.6.1 及更高版本还允许使用 git diff --staged，效果相同但更好记些。） 4.移除文件1git rm filename要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。可以用 git rm 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。 5.将文件从暂存区移除1git rm --cached filename已添加到暂存区的文件会被移除，但是本地的修改不会被删除，仍然保留工作在工作目录中。 6.移动文件1git mv file_from file_to如果我们想要重命名文件或者将文件移动到另一个文件夹下面，可以使用此种方式。 7.提交更新到本地仓库1git commit -m &quot;commit message&quot; Git 提交记录 - git log1git log 按提交时间列出所有的更新，列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。 1.显示指定文件所有的更新1git log filename 2.显示最近n次的提交记录1git log -n 3.显示每次提交的内容差异1git log -p 以上参数可以混合使用。例如，查看 README 文件最近两次提交的内容差异：1git log -p -2 README.md 4.查看每次提交的简略统计信息1git log --stat --stat 选项在每次提交的下面列出所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。在每次提交的最后还有一个总结。 5.使用 --pretty=oneline 将每个提交放在一行显示，查看的提交数很大时非常有用1git log --pretty=oneline 6.显示指定作者相关的提交1git log --author=&quot;author_name&quot; 7.显示包含指定关键字的提交1git log --grep=&quot;keyword&quot; 8.查看指定 SHA-1 的提交1git show commit-hash-id该命令会列出此次提交的提交信息以及内容变化，用于快速查看某个历史提交的提交信息以及修改内容。 比如我们先查看 README 文件的提交记录：123$ git log --oneline README.md75b684b Update README.md0adb202 Initial commit现在我们想知道 75b684b 详细的提交信息以及做了什么修改，就可以使用这个命令：123456789101112131415$ git show 75b684bcommit 75b684b16c6fc9378973bc5851db03a440f7c763Author: neo1949 &lt;neo1949@qq.com&gt;Date: Mon May 21 16:19:19 2018 +0800 Update README.mddiff --git a/README.md b/README.mdindex 095d88d..140c9b4 100644--- a/README.md+++ b/README.md@@ -1,2 +1,2 @@ # GitTest-A project used to test git command.+A project used to learn and record git commands. Git 强大的地方不仅在于提供了丰富的命令，更重要的是可以组合使用这些命令找到我们想要的结果。比如，我想查看作者 neo1949 提交中包含关键字 test 最近的5条记录，可以使用如下的方式：1git log --author=neo1949 --grep=test -5这里需要注意的是：因为作者名不包含空格，所以可以不使用“”引用，关键字同理。如果你的用户名包含关键字或者关键字是短语，那么必现要使用“”。 关于 git log 更详细的用法请参考 查看提交历史 章节。 撤消操作1.覆盖提交1git commit --amend有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。此时，可以先将未添加的文件添加到暂存区后（更新提交信息跳过即可），再使用 --amend 选项提交命令尝试重新提交。 2.取消暂存的文件但保留本地修改1git reset HEAD filename与 git rm --cached filename 命令作用相同，都是取消暂存的文件，但是本地的修改仍在，工作内容不会丢失。 3.撤消对文件的修改1git checkout filname撤消本地文件的所有修改，本地所有修改的工作内容都会被删除。需要注意的是，只有文件处于已跟踪但未暂存的状态，此命令才会生效。如果是新增的文件或者已添加到暂存区的文件，使用这个命令不会删除本地的修改。 远程仓库的使用查看远程仓库如果想查看你已经配置的远程仓库服务器，可以运行 git remote 命令。它会列出你指定的每一个远程服务器的简写。如果你已经克隆了自己的仓库，那么至少应该能看到 origin - 这是 Git 给你克隆的仓库服务器的默认名字：12$ git remoteorigin 使用 -v 参数显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL：123$ git remote -vorigin git@github.com:neo1949/GitTest.git (fetch)origin git@github.com:neo1949/GitTest.git (push) 添加远程仓库使用下面的命令添加一个新的远程 Git 仓库，同时指定一个你可以轻松引用的简写：1git remote add &lt;shortname&gt; &lt;url&gt;现在你可以在命令行中使用字符串 shortname 来代替整个 URL。 从远程仓库中拉取与抓取1.从远程仓库中获得数据1git fetch 如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。所以，git fetch origin 会抓取克隆（或上一次抓取）后新推送的所有工作。必须注意 git fetch 命令会将数据拉取到你的本地仓库，但它并不会自动合并或修改你当前的工作。当准备好时你必须手动将其合并入你的工作。 2.推送到远程分支1git push [remote-name] [branch-name] 当你想要将 master 分支推送到 origin 服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字），那么运行这个命令就可以将你所做的备份到服务器：1$ git push origin master 3.查看远程仓库1git remote show [remote-name] 例如：查看远程仓库 origin 的详细信息123456789101112$ git remote show origin* remote origin Fetch URL: git@github.com:neo1949/GitTest.git Push URL: git@github.com:neo1949/GitTest.git HEAD branch: master Remote branches: master tracked tmp tracked Local branch configured for 'git pull': master merges with remote master Local ref configured for 'git push': master pushes to master (up to date)这些信息非常有用，它会列出远程仓库的 URL 与跟踪分支的信息。它会告诉你正处于哪个分支。比如本例中可以看到你当前处于 master 分支，如果你运行 git pull 命令，Git 就会自动抓取所有的远程引用，然后将远程 master 分支合并到本地 master 分支。它也会列出拉取到的所有远程引用。 这个命令还会列出当你在特定的分支上执行 git push 命令式会自动地推送到哪一个远程分支。同时还会列出哪些远程分支不在你的本地，哪些远程分支已经从服务器上移除了，还有当你执行 git pull 时哪些分支会自动合并。 4.重命名远程仓库1git remote rename old-remote-name new-remote-name值得注意的是这同样也会修改你的远程分支名字。那些过去引用 old-remote-name/master 的现在会引用 new-remote-name/master。 5.移除远程仓库1git remote rm remote-name如果因为一些原因想要移除一个远程仓库：你已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者某一个贡献者不再贡献了，可以使用上面的命令删除某个远程仓库。 Git 标签 - git tagGit 可以给历史中的某一个提交打上标签，通常用来标记发布结点。 列出标签1git tag 创建标签1git tag -a tag-name -m &quot;tag message&quot; 例如：1234$ git tag -a v0.2 -m &quot;Add tag v0.2 for test&quot;$ git tagv0.1v0.2 查看标签信息1git show tag-name 后期打标签如果我们在某次提交忘记给项目打标签，可以之后补上标签。要在那个提交上打标签，只需要在命令的末尾指定提交的校验和（或部分校验和）:1git tag -a tag-name commit-hash-id 共享标签默认情况下，git push 命令并不会传送标签到远程仓库服务器上。在创建完标签后你必须显式地推送标签到共享服务器上。这个过程就像共享远程分支一样:1git push origin tag-name 如果想要一次性推送很多标签，也可以使用带有 --tags 选项，这将会所有不在远程仓库服务器上的标签全部推送到远程仓库中：1git push origin --tags 这样其它人拉取仓库的时候也能看到这些标签了。 检出标签在 Git 中你并不能真的检出一个标签，因为它们并不能像分支一样来回移动。如果你想要工作目录与仓库中特定的标签版本完全一样，可以在特定的标签上创建一个新分支并切换到该分支：1git checkout -b [branch-name] [tag-name] 通过该命令可以实现下载某个仓库指定版本的代码，例如：1234567$ git clone git@github.com:neo1949/GitTest.git GitTest2$ cd GitTest2$ git tagv0.1v0.2v0.3$ git checkout v0.2有时候我们会需要一个特定版本的程序，可以通过上面的方法先下载指定版本的代码，然后编译程序即可。 Git 别名强烈建议不要一开始就使用别名，一定要在熟练使用 Git 之后再使用别名，具体请自行参考 Git 别名。 Git 分支分支简介想要真正理解 Git 处理分支的方式，首先需要了解 Git 是如何保存数据的。 Git 保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照。 在进行提交操作时，Git 会保存一个提交对象（commit object）。知道了 Git 保存数据的方式，我们可以很自然的想到——该提交对象会包含一个指向暂存内容快照的指针。但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象： 当使用 git commit 进行提交操作时，Git 会先计算每一个子目录的校验和，然后在 Git 仓库中这些校验和保存为树对象。随后，Git 便会创建一个提交对象，它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。如此一来，Git 就可以在需要的时候重现此次保存的快照。 创建分支Git 在创建分支时，只是创建了一个可以移动的新的指针：1git branch new-branch Git 有一个名为 HEAD 的特殊指针，指向当前所在的本地分支。 使用 git log --decorate 可以查看各个分支当前所指的对象：12345678910111213141516$ git log --decorate --onelineaed99ae (HEAD, tag: v0.3, origin/master, master) Summary: add tag.md for test67aa248 (tag: v0.2) Create TestFetch.md4ee2795 Summary: remove Chapter_02_branch.mda7e5abc Summary: update Chapter_02_branch.md80d1cf2 Summary: add Chapter_02_branch.mde07e4ca (origin/tmp, origin/dev, tmp, test, dev) Merge branch 'master' of github.com:neo1949/GitTest2d9c922 Summary: update Chapter_01_init.mda5d6af0 Summary: update Chapter_01_init.mdbb3fb11 Merge branch 'master' of github.com:neo1949/GitTestb9c24d5 Summary: update Chapter_01_init.mdc11ceb1 Summary: update Chapter_01_init.mdc349273 Merge branch 'master' of github.com:neo1949/GitTest0b90633 Summary: create a git repo75b684b (tag: v0.1) Update README.md0adb202 Initial commit可以看到 master 分支指向 aed99ae 开头的提交对象，而 tmp 和 dev 分支则指向 e07e4ca 开头的提交对象。 查看分支1.查看所有本地分支1git branch* 表示当前所在的分支（也就是 HEAD 指针指向的分支）。 2.查看所有分支1git branch -a 3.查看所有远程分支1git branch -r 4.查看每个分支的最后一次提交1git branch -v 5.查看已经合并到当前分支的分支1git branch --merged 6.查看未合并到当前分支的分支1git branch --no-merged 切换分支1.切换到指定分支：1git checkout branch-name 2.创建分支并切换到新的分支：1git checkout -b new-branch 创建一个新分支后并切换过去进行了一些工作，随后又切换回 master 分支进行了另外一些工作，提交到仓库之后，这个项目的提交历史就产生了分叉，可以用下面的方式查看项目分叉历史：12345678910111213141516171819202122$ git log --decorate --oneline --graph --all* aed99ae (HEAD, tag: v0.3, origin/master, master) Summary: add tag.md for test* 67aa248 (tag: v0.2) Create TestFetch.md* 4ee2795 Summary: remove Chapter_02_branch.md* a7e5abc Summary: update Chapter_02_branch.md* 80d1cf2 Summary: add Chapter_02_branch.md* e07e4ca (origin/tmp, origin/dev, tmp, test, dev) Merge branch 'master' of github.com:neo1949/GitTest|\\| * a5d6af0 Summary: update Chapter_01_init.md* | 2d9c922 Summary: update Chapter_01_init.md|/* bb3fb11 Merge branch 'master' of github.com:neo1949/GitTest|\\| * c11ceb1 Summary: update Chapter_01_init.md* | b9c24d5 Summary: update Chapter_01_init.md|/* c349273 Merge branch 'master' of github.com:neo1949/GitTest|\\| * 75b684b (tag: v0.1) Update README.md* | 0b90633 Summary: create a git repo|/* 0adb202 Initial commit 合并分支分支的合并请仔细阅读 分支的创建与合并 章节中“分支的合并”部分，主要记住合并分支的命令是 git merge branch-name。关于如何解决合并时的冲突，文档里面提供详细了的介绍，请仔细阅读。 下面我们将在本地模拟合并分支冲突的情形： 1.首先在主分支 master 创建一个空文件 “merge_conflict_test.md”，然后将其提交到远程仓库 master 分支上：123$ git add merge_conflict_test.md$ git commit -m &quot;Add merge_conflict_test.md file for test&quot;$ git push origin master 2.在本地创建一个 merge_demo 并切换到该分支：1git checkout -b merge_demo 3.打开 “merge_conflict_test.md” 文件，在第一行添加一句话： This line was added on merge_demo branch. 4.将文件提交到仓库后切换回主分支：123$ git add merge_conflict_test.md$ git commit -m &quot;Add a line in merge_conflict_test.md on merge_demo branch&quot;$ git checkout master切回到主分支后查看 “merge_conflict_test.md” 文件，可以看到我们刚才添加的那行内容不见了。这是必然的，因为我们的修改是在 merge_demo 分支上进行的。 5.接下来再次在 “merge_conflict_test.md” 文件的第一行添加一句话： This line was added on master branch. 按照上面同样的方式将文件提交到仓库中：12$ git add merge_conflict_test.md$ git commit -m &quot;Add a line in merge_conflict_test.md on master branch&quot; 6.下面将 merge_demo 合并到 master 分支中：1234$ git merge merge_demoAuto-merging merge_conflict_test.mdCONFLICT (content): Merge conflict in merge_conflict_test.mdAutomatic merge failed; fix conflicts and then commit the result. 可以看到 Git 提示我们合并分支发生了冲突，需要我们解决冲突后提交结果。 7.查看此时文件 “merge_conflict_test.md” 的内容如下：123456$ cat merge_conflict_test.md&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADThis line was added on master branch.=======This line was added on merge_demo branch.&gt;&gt;&gt;&gt;&gt;&gt;&gt; merge_demo 这表示 HEAD 所指示的版本（也就是 master 分支所在的位置）在这个区段的上半部分（======= 的上半部分），而 merge_demo 分支所指示的版本在 ======= 的下半部分。根据实际情况来确定需要删除和保留哪些内容。 8.解决冲突后再次将文件提交到仓库：1234567891011121314151617$ cat merge_conflict_test.mdThis line was added on master branch.This line was added on merge_demo branch.This line was added to show how fixing conflict.$ git statusOn branch masterYou have unmerged paths. (fix conflicts and run &quot;git commit&quot;)Unmerged paths: (use &quot;git add &lt;file&gt;...&quot; to mark resolution) both modified: merge_conflict_test.mdno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)$ git add merge_conflict_test.md$ git commit 使用 git commit 提交时可以看到系统自动添加了哪个文件发生了合并冲突的提交说明：12345Merge branch 'merge_demo'# Conflicts:# merge_conflict_test.md# ... 通过这个例子可以看到，如果在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们从而导致合并冲突。 现在我们应该已经学会如何解决合并冲突的问题了！ 删除分支1.删除本地分支1git branch -d branch-name 2.强制删除本地分支（忽略冲突）1git branch -D branch-name 3.删除远程仓库的分支1git push origin --delete branch-name 官方文档对这个命令有一段说明：基本上这个命令做的只是从服务器上移除这个指针。Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。 网上还介绍了一种删除远程分支的方法：1git push origin :branch-name这种方式也可以删除远程仓库里的分支，但是是否会保留数据未知，所以如果误删除了某个分支，可能无法恢复数据，为了安全起见，不推荐使用此种方式删除远程分支。 删除远程仓库分支之后，使用 git branch -a 查看分支信息，发现刚才删除的远程分支依然能看到，可以使用 git remote prune origin 命令后再查看分支信息，不会再显示已删除的远程分支。 下面完整地演示如何将一个 dev 分支添加到远程仓库后再删除的流程：123456789101112131415161718192021222324252627282930$ git branch -a* master remotes/origin/master remotes/origin/tmp$ git branch dev$ git push origin devTotal 0 (delta 0), reused 0 (delta 0)To git@github.com:neo1949/GitTest.git * [new branch] dev -&gt; dev$ git branch -a dev* master remotes/origin/dev remotes/origin/master remotes/origin/tmp$ git push origin --delete devTo git@github.com:neo1949/GitTest.git - [deleted] dev$ git branch -a dev* master remotes/origin/dev remotes/origin/master remotes/origin/tmp$ git remote prune origin$ git branch -a dev* master remotes/origin/master remotes/origin/tmp 远程分支远程分支的概念请先阅读 远程分支。以下为个人摘录总结，可能存在理解错误。 远程引用是对远程仓库的引用（指针），包括分支、标签等等。可以通过 git ls-remote (remote) 来显式地获得远程引用的完整列表，或者通过之前介绍过的 git remote show (remote) 命令获得远程分支的更多信息。通常更常见的做法是利用远程跟踪分支。 远程跟踪分支是远程分支状态的引用，以 (remote)/(branch) 形式命名。你不能移动这些本地引用，当你做任何网络通信操作时，它们会自动移动。远程跟踪分支像是你上次连接到远程仓库时，那些分支所处状态的书签。使用 git clone 命令克隆仓库时，系统会自动将其命名为 origin，拉取它的所有数据，创建一个指它的 master 分支的指针，并且在本地将其命名为 origin/master。同时，Git 会在本地创建一个与 origin 的 master 指向同一个地方的 master 分支，这样可以方便你开展工作。 需要再次明确一点：origin 并无特殊含义。远程仓库名字 origin 与分支名字 master 一样，在 Git 中并没有任何特别的含义。master 是运行 git init 时默认的起始分支名字，原因仅仅是它的广泛使用。origin 是运行 git clone 时默认的远程仓库名字，如果你运行 git clone -o booyah，那么你默认的远程跟踪分支名字将会是 booyah/master。 演示：1234567$ git clone -o work git@github.com:neo1949/GitTest.git GitTest2$ cd GitTest2$ git branch -a* master remotes/work/HEAD -&gt; work/master remotes/work/master remotes/work/tmp 可以看到 git clone -o remote-name 实际上相当于先执行了 克隆仓库 的命令，然后又执行了 重命名仓库 的操作：12345678910111213$ git clone git@github.com:neo1949/GitTest.git GitTest2$ cd GitTest2$ git branch -a* master remotes/origin/HEAD -&gt; origin/master remotes/origin/master remotes/origin/tmp$ git remote rename origin work$ git branch -a* master remotes/work/HEAD -&gt; work/master remotes/work/master remotes/work/tmp 所以，完整的克隆仓库命令如下：1git clone [-o shortname] url [local-repo-name] shortname ：使用 shortname 作为远程仓库名，不指定该参数时使用 origin 作为远程仓库名 local-repo-name ：使用 local-repo-name 作为工作目录名称，不指定该参数时使用远程仓库名创建工作目录 将本地分支推送远程仓库1git push remote-name branch-name[:remote-branch-name] 想要把一个分支推送到远程仓库上，必须要有这个仓库的写入权限。使用 git push remote-name branch-name 将本地分支推送到远程仓库中，系统会在远程仓库中创建一个名为 branch-name 的分支。如果我们并不想让远程仓库上的分支叫做branch-name，而是想使用一个新的分支名，可以使用 git push remote-name branch-name:remote-branch-name 的方式将本地 branch-name 分支推送到远程仓库上的 remote-branch-name 分支。 示例：123456789101112$ git branch local-dev$ git push origin local-dev$ git branch -alocal-dev* masterremotes/origin/HEAD -&gt; origin/masterremotes/origin/devremotes/origin/local-devremotes/origin/masterremotes/origin/teamremotes/origin/testremotes/origin/tmp可以看到远程仓库中多了一个 local-dev 分支。 1234567891011121314$ git branch local-cache$ git push origin local-cache:origin-cache$ git branch -alocal-cachelocal-dev* masterremotes/origin/HEAD -&gt; origin/masterremotes/origin/devremotes/origin/local-devremotes/origin/masterremotes/origin/remote-cacheremotes/origin/teamremotes/origin/testremotes/origin/tmp 可以看到远程仓库多了一个 remote-cache 分支。 删除远程分支删除远程分支 和 删除本地分支 的命令在前面已经介绍过了，现在我们来删除刚才用于演示的 local-dev 和 local-cache 本地分支，以及它们对应的远程仓库中的分支：123456789101112$ git branch -d local-dev$ git push origin --delete local-dev$ git branch -d local-cache$ git push origin --delete remote-cach$ git branch -a* master remotes/origin/HEAD -&gt; origin/master remotes/origin/dev remotes/origin/master remotes/origin/team remotes/origin/test remotes/origin/tmp可以看到远程库中的 local-dev 和 remote-cache 分支都被删除掉了。 跟踪分支从一个远程跟踪分支检出一个本地分支会自动创建一个叫做 “跟踪分支”（有时候也叫做 “上游分支”）。跟踪分支是与远程分支有直接关系的本地分支。如果在一个跟踪分支上输入 git pull，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。 前面我们已经知道，当克隆一个仓库时，它会自动地创建一个跟踪 origin/master 的 master 分支。然而，如果你愿意的话可以设置其他的跟踪分支 - 跟踪其他远程仓库上的分支或者不跟踪 master 分支。 假设有个小组的管理人员在本地创建了 team 分支并将其推送了远程仓库，现在指定小组内的所有人都要在这个 team 分支上进行工作。当管理人员将 team 分支推送到远程仓库后，其他人通过 git fetch 从服务器上抓取数据时，他们会在本地生成一个 origin/team 远程分支，指向服务器中 team 分支的引用。 需要特别注意是当抓取到新的远程跟踪分支时，本地并不会自动生成一份可编辑的副本（拷贝）。换句话说，系统不会在本地创建一个 team 分支，只有一个不可修改的 origin/team 指针。那么我们如何创建一个跟踪 team 分支的本地分支呢？有三种实现方式： 1.第一种123$ git checkout --track origin/teamBranch team set up to track remote branch team from origin.Switched to a new branch 'team' 2.第二种123$ git checkout -b team origin/teamBranch team set up to track remote branch team from origin.Switched to a new branch 'team'当然了，我们可以将本地分支与远程分支设置为不同的名字，只需要将 team 换成我们需要的名字即可。比如运行 git checkout -b my-team origin/team，现在 my-team 被设置为用来跟踪远程仓库中的 team，本地分支 my-team 会自动从 origin/team 拉取数据。 3.第三种1234$ git checkout -b teamSwitched to a new branch 'team'$ git branch -u origin/teamBranch team set up to track remote branch team from origin.我们可以先创建一个本地分支，然后切换到该分支后执行 git branch -u remote-name/branch-name 或者 git branch --set-upstream-to=remote-name/branch-name 命令来显示地设置让当前本地分支追踪某个上游分支。通过这个命令我们还可以修改正在跟踪的上游分支。比如我们刚才让本地的 team 追踪上游的 team，现在我们在 team 分支上的所有工作都完成了并且合并到了主分支 master 上面，后续的工作基于 master 分支继续进行就可以了，那么我们现在就可以使用 git branch -u origin/master 让 team 追踪主分支 master，这样我们就可以在 team 分支上继续工作了。 想要查看设置的所有跟踪分支，可以使用git branch -vv 命令。这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支，本地分支是否是领先、落后或是都有。 示例：1234$ git branch -vv dev 2617b13 [origin/dev] Merge branch 'test' master 2617b13 [origin/master] Merge branch 'test'* team 2617b13 [origin/team: behind 1] Merge branch 'test'可以看到 dev 分支正在跟踪 origin/dev 分支并且是最新的。也能看到 master 分支正在跟踪 origin/master 分支并且也是最新的。最后可以看到 team 分支正在跟踪 origin/team 分支并且落后1，意味着服务器上还有一次提交没有合并到本地。如果我们看到 ahead x 之类的提交信息，意味着本地有x次提交还没有推送到服务器上。 需要注意的是这些数字的值只是来自于你从每个服务器上最后一次抓取的数据。这个命令并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。如果想要统计最新的领先与落后数字，需要先运行 git fetch --all 命令后再运行查看跟踪分支的命令。 拉取数据使用 git fetch 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容，它只会获取数据然后让你自己合并。然而，有一个命令叫作 git pull， 在大多数情况下它的含义是一个 git fetch 紧接着一个 git merge 命令。如果你像之前章节中演示的那样设置好了一个跟踪分支，不管它是显式地设置还是通过 clone 或 checkout 命令创建的，git pull 都会查找当前分支所跟踪的服务器与分支，从服务器上抓取数据然后尝试合并入那个远程分支。 由于 git pull 的魔法经常令人困惑，所以通常单独显式地使用 fetch 与 merge 命令会更好一些。 变基在 Git 中整合来自不同分支的修改主要有两种方法：merge 以及 rebase。关于 merge 以及 rebase 命令的原理请参考文档 变基。我们已经在前面 合并分支 章节介绍过了如何使用 merge 命令，现在开始介绍如何使用 rebase 命令。还是以实例操作来演示，这样方便直观，便于理解和学习。 1.首先切换到 master 分支，在 log.md 文件上添加一行说明性文字，然后将修改提交到仓库中：1234567$ git checkout master$ git add log.md$ git commit -m &quot;Generate a commit log in repository for 'git rebase' test&quot;$ git push origin master$ git log --oneline -213f83a3 Summary: Generate a commit log in repository for 'git rebase' test2617b13 Merge branch 'test'稍后我们将以 13f83a3 为节点来演示 rebase 操作。 2.新建一个 rebase_demo 分支，切换到该分支后按照如下步骤操作：1234567$ git checkout -b rebase_demo$ touch rebase_on_rebase_demo.md$ git add rebase_on_rebase_demo.md$ git commit -m &quot;Add rebase_on_rebase_demo.md file on rebase_demo branch&quot;$ git log --oneline -2176ec79 Add rebase_on_rebase_demo.md file on rebase_demo branch13f83a3 Summary: Generate a commit log in repository for 'git rebase' test现在我们在 rebase_demo 分支上有了一个 176ec79 提交。 3.切回 master 分支，按如下步骤操作：1234567$ git checkout master$ touch rebase_on_master.md$ git add rebase_on_master.md$ git commit -m &quot;Add rebase_on_master.md file in master branch&quot;$ git log --oneline -26340e0d Add rebase_on_master.md file in master branch13f83a3 Summary: Generate a commit log in repository for 'git rebase' test现在我们在 master 分支上有了一个 6340e0d 提交。 我们知道 176ec79 和 6340e0d 的共同祖先是 13f83a3。 使用 merge 命令将 rebase_demo 分支上的修改合并到 master 分支时，Git 会对 176ec79 、6340e0d 以及 13f83a3 进行三方合并，生成一个新的快照（并提交）。除了通过合并整合分叉的历史，还有一种方法就是使用 rebase 命令。方法如下：首先提取在 176ec79 中引入的补丁和修改，然后在 6340e0d 的基础上应用一次。 在 Git 中，这种操作就叫做 变基。你可以使用 rebase 命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。命令操作如下：1234$ git checkout rebase_demo$ git rebase masterFirst, rewinding head to replay your work on top of it...Applying: Add rebase_on_rebase_demo.md file on rebase_demo branch 它的原理是首先找到这两个分支（即当前分支 rebase_demo、变基操作的目标基底分支 master）的最近共同祖先 13f83a3，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底 6340e0d，最后以此将之前另存为临时文件的修改依序应用。 现在回到 master 分支进行一次快进合并：123456$ git checkout master$ git merge rebase_demo$ git log --oneline --graph -3* 827ff4b Add rebase_on_rebase_demo.md file on rebase_demo branch* 6340e0d Add rebase_on_master.md file in master branch* 13f83a3 Summary: Generate a commit log in repository for 'git rebase' test 此时，827ff4b 指向的快照就和使用 merge 命令最终生成的快照一模一样了。这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。上面我们用命令查看经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的，但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。 一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个其他人维护的项目贡献代码时。在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 origin/master 上，然后再向主项目提交修改。这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。 请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。 关于变基的一些更高级的操作请阅读 变基 中更有趣的例子。必须记住，使用变基必须要准守一条准则：不要对在你的仓库外有副本的分支执行变基。如果你遵循这条金科玉律，就不会出差错。否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。 选择修订版本简短的 SHA-1当我们使用 git log 查看提交记录时，提交记录格式是这样的：123456commit 2617b1375f85f0591c459e880497c6f767ddf356Merge: 0c61754 05d597eAuthor: neo1949 &lt;neo1949@qq.com&gt;Date: Sun May 27 15:49:32 2018 +0800 Merge branch 'test' Git 可以为 2617b1375f85f0591c459e880497c6f767ddf356 这样的 SHA-1 生成出简短且唯一的缩写，通过 git log --abbrev-commit 命令可以使输出结果显示简短且唯一的值：123456commit 2617b13Merge: 0c61754 05d597eAuthor: neo1949 &lt;neo1949@qq.com&gt;Date: Sun May 27 15:49:32 2018 +0800 Merge branch 'test' SHA-1 缩写默认使用七个字符，不过有时为了避免 SHA-1 的歧义，会增加字符数，通常 8 到 10 个字符就已经足够在一个项目中避免 SHA-1 的歧义。 引用日志工作时 Git 会在后台保存一个引用日志(reflog)，引用日志记录了最近几个月 HEAD 和分支引用所指向的历史。使用 git reflog 来查看引用日志：1234567$ git reflog13f83a3 HEAD@{0}: reset: moving to 13f83a3827ff4b HEAD@{1}: merge rebase_demo: Fast-forward6340e0d HEAD@{2}: checkout: moving from rebase_demo to master827ff4b HEAD@{3}: rebase finished: returning to refs/heads/rebase_demo827ff4b HEAD@{4}: rebase: Add rebase_on_rebase_demo.md file on rebase_demo branch...... 参考文章Git 官方中文手册Difference between CR LF, LF and CR line break types?","link":"/2018/03/19/git-common-commands/"},{"title":"【译】 How to read Dalvik SIGQUIT output","text":"原文：How to read Dalvik SIGQUIT output 限于本人英语水平，且对原文中的相关专业术语缺乏了解，因此翻译难免会有错误和歧义，欢迎大家指教。在翻译时对译文做了分段处理，并在译文相关地方添加了一些辅助说明，不需要译文的请直接点击上面的链接（需科学上网）查看原文。 翻译文章的目的是通过翻译的过程学习相关知识，而且可以做个备份，日后再需要使用的时候可以很方便的查阅。英文水平差无关紧要，有谷歌翻译可以帮助我们解决大部分问题，再加上自己的一点理解即可。闲话不再多说，下面开始进入正文。 引言 If you’re a long-time Java developer you’re probably used to sending SIGQUIT to a Java process (either via kill -3 or hitting ctrl-) to see what all the threads are doing. You can do the same with Dalvik (via adb shell kill -3), and if you’re ANRing the system server will be sending you SIGQUIT too, in which case the output will end up in /data/anr/traces.txt (see the logcat output for details). 如果你是一位长期从事 Java 开发的人员，那么你可能已经习惯于将 SIGQUIT 发送给 Java 进程（通过 kill -3 或者 敲击 Ctrl-\\）来查看所有线程正在执行的操作。你可以使用 Dalvik （通过 adb shell kill -3）做同样的事情，系统服务也会向你发送 SIGQUIT，这种情况下输出将会被保存到 /data/anr/traces.txt 中（请参阅 logcat 输出获取详细信息）。 Anyway, I’ve found that very few people actually know what all the output means. I only knew a few of the more important bits until I became a Dalvik maintainer. This post should hopefully clear things up a little. 总之，我发现很少有人真正知道所有的输出是是什么意思。在成为 Dalvik 维护人员之前，我也只是知道一些更重要的部分。希望这篇文章能够澄清一些事情。 示例及说明 To start with, here’s an example from my JNI Local Reference Changes in ICS post: 首先，这是我在 ICS post 中 JNI Local Reference Changes 的一个例子：123456\"Thread-10\" prio=5 tid=8 NATIVE | group=\"main\" sCount=0 dsCount=0 obj=0xf5f77d60 self=0x9f8f248 | sysTid=22299 nice=0 sched=0/0 cgrp=[n/a] handle=-256476304 | schedstat=( 153358572 709218 48 ) utm=12 stm=4 core=8 at MyClass.printString(Native Method) at MyClass$1.run(MyClass.java:15) Ignore the Java stack trace for now. If there’s demand, I’ll come back to that later, but there’s nothing interesting in this particular example. Let’s go through the other lines… 现在请暂时忽略 Java 堆栈跟踪。 如果有需求，我会在稍后说明，但这个例子中没有什么令人关注的。我们来看看其它行的信息： First, though, a quick note on terminology because there are a lot of different meanings of “thread” that you’ll have to keep clear. If I say Thread, I mean java.lang.Thread. If I say pthread, I mean the C library’s abstraction of a native thread. If I say native thread, I mean something created by the kernel in response to a clone(2) system call. If I say Thread*, I mean the C struct in the VM that holds all these things together. And if I say thread, I mean the abstract notion of a thread. 首先是关于术语的简要说明，因为你必须明白 thread 有许多不同的含义。 如果我说 Thread，我的意思是 java.lang.Thread。如果我说 pthread，我的意思是C库的本地线程的抽象。如果我说本地线程，我的意思是内核创建的响应克隆（2）系统调用的东西。如果我说 Thread *，我的意思是 VM 中将所有这些东西放在一起的 C 结构。如果我说 thread，我的意思是线程的抽象概念。 第一行参数说明1&quot;Thread-10&quot; prio=5 tid=8 NATIVE The thread name comes first, in quotes. If you gave a name to a Thread constructor, that’s what you’ll see here. Otherwise there’s a static int in Thread that’s a monotonically increasing thread id, used solely for giving each thread a unique name. These thread ids are never reused in a given VM (though theoretically you could cause the int to wrap). 首先是引号中的线程名称。如果你向 Thread 的构造函数传递了一个名称，那么你会在这里看到。否则，Thread 中有一个静态 int，它是一个单调递增的线程 ID，仅用于给每个线程一个唯一的名称。这些线程 ID 不会在给定的虚拟机中重用（尽管理论上你可能会导致 int 溢出）。 The thread priority comes next. This is the Thread notion of priority, corresponding to the getPriority and setPriority calls, and the MIN_PRIORITY, NORM_PRIORITY, and MAX_PRIORITY constants. 接下来是线程优先级。这是 Thread 的优先级概念，对应于 getPriority 和 setPriority 调用，以及 MIN_PRIORITY，NORM_PRIORITY 和 MAX_PRIORITY 常量。 java.lang.Thread 中对于三个常量的定义如下：1234567891011121314/** * The minimum priority that a thread can have. */public static final int MIN_PRIORITY = 1;/** * The default priority that is assigned to a thread. */public static final int NORM_PRIORITY = 5;/** * The maximum priority that a thread can have. */public static final int MAX_PRIORITY = 10; The thread’s thin lock id comes next, labelled “tid”. If you’re familiar with Linux, this might confuse you; it’s not the tid in the sense of the gettid(2) system call. This is an integer used by the VM’s locking implementation. These ids come from a much smaller pool, so they’re reused as threads come and go, and will typically be small integers. 接下来是标记为 tid 的线程的 thin lock ID。如果你熟悉 Linux，这可能会让你困惑；它不是 gettid 系统调用意义上的 tid。这是 VM 锁定实现所使用的整数。这些 ID 来自一个小得多的池，所以它们在线程来来去去时被重用，并且通常是小整数。 关于什么是 thin lock id，请参考 Understanding Threads and Locks 中对于 Locks 的说明。 The thread’s state comes last. These states are similar to, but a superset of, the Thread thread states. They can also change from release to release. At the time of writing, Dalvik uses the following states (found in enum ThreadStatus in vm/Thread.h): 最后是线程的状态。这些状态与 Thread 的线程状态类似，但是是超线程状态。它们从一个版本到另一个版本可能发生变化。在撰写本文时，Dalvik使用以下状态（可在 vm/Thread.h 的枚举 ThreadStatus 中找到）： 123456789101112/* these match up with JDWP values */THREAD_ZOMBIE = 0, /* TERMINATED */THREAD_RUNNING = 1, /* RUNNABLE or running now */THREAD_TIMED_WAIT = 2, /* TIMED_WAITING in Object.wait() */THREAD_MONITOR = 3, /* BLOCKED on a monitor */THREAD_WAIT = 4, /* WAITING in Object.wait() *//* non-JDWP states */THREAD_INITIALIZING = 5, /* allocated, not yet running */THREAD_STARTING = 6, /* started, not yet on thread list */THREAD_NATIVE = 7, /* off in a JNI native method */THREAD_VMWAIT = 8, /* waiting on a VM resource */THREAD_SUSPENDED = 9, /* suspended, usually by GC or debugger */ You won’t see ZOMBIE much; a thread is only in that state while it’s being dismantled. RUNNING is something of a misnomer; the usual term is “runnable”, because whether or not the thread is actually scheduled on a core right now is out of the VM’s hands. TIMED_WAIT corresponds to an Object.wait(long, int) call. Note that Thread.sleep and Object.wait(long) are currently both implemented in terms of this. WAIT, by contrast, corresponds to a wait without a timeout, via Object.wait(). MONITOR means that the thread is blocked trying to synchronize on a monitor, Either because of a synchronized block or an invoke of a synchronized method (or theoretically, on a call to JNIEnv::MonitorEnter). 你不会经常看到 ZOMBIE 状态，一个线程只有在被拆除时才会处于该状态。RUNNING 不是很贴切，通常术语是“running”，因为无论线程是否在一个核心上，现在已经不在 VM 的掌控中了。TIMED_WAIT 对应于 Object.wait(long，int) 调用。请注意， Thread.sleep 和 Object.wait(long) 目前都是以这种方式实现的。相反，WAIT 对应于通过 Object.wait() 实现的没有超时的等待。MONITOR 意味着线程被阻塞，试图在监视器上进行同步，或者是因为同步块或调用同步方法（或理论上在调用 JNIEnv :: MonitorEnter 时）。 The INITIALIZING and STARTING states are aspects of the current (at the time of writing) implementation of the thread startup dance. As an app developer, you can probably just chunk these two as “too early to be running my code”. NATIVE means that the thread is in a native method. VMWAIT means that the thread is blocked trying to acquire some resource that isn’t visible to managed code, such as an internal lock (that is, a pthread_mutex). SUSPENDED means that the thread has been told to stop running and is waiting to be allowed to resume; as the comment says, typically as an app developer you’ll see this because there’s a GC in progress or a debugger is attached. INITIALIZING 和 STARTING 状态是当前（编写时）线程启动舞蹈的实现方面。 作为一名应用程序开发人员，您可能只是将这两者分成“过早运行我的代码”。NATIVE 意味着线程处于本地方法。VMWAIT 意味着线程被阻塞，试图获取某些托管代码不可见的资源，例如内部锁（即pthread_mutex）。SUSPENDED 意味着线程已被告知停止运行，并且正在等待被允许恢复; 正如评论所说，通常作为应用程序开发人员，你会看到这一点，因为有 GC 正在进行或者附加了调试程序。 Not shown in this example, a daemon thread will also say “daemon” at the end of the first line. 在这个例子中没有展示，一个守护线程通常会第一行的末尾使用 daemon 说明。 第二行参数说明1| group=&quot;main&quot; sCount=0 dsCount=0 obj=0xf5f77d60 self=0x9f8f248 The Thread’s containing ThreadGroup name comes next, in quotes. 接下来是用引号括起来的包含 ThreadGroup 的线程名称。 The sCount and dsCount integers relate to thread suspension. The suspension count is the number of outstanding requests for suspension for this thread; this is sCount. The number of those outstanding requests that came from the debugger is dsCount, recorded separately so that if a debugger detaches then sCount can be reset appropriately (since there may or may not have been outstanding non-debugger suspension requests, we can’t just reset sCount to 0 if a debugger disconnects). sCount 和 dsCount 整数与线程挂起有关。暂停计数是此线程未决请求的数量，这是 sCount。来自调试器的未完成请求的数量是 dsCount，分开记录，以便如果调试器分离，则可以适当地重置sCount（因为可能有或可能没有未完成的非调试器暂停请求，如果调试器断开，我们不能只把 sCount 重置为0）。 (If there’s demand, I’ll talk more about thread suspension in another post, including when suspension can occur, and what suspension means for unattached threads and threads executing native methods.) 如果有需要，我会在另一篇文章中谈谈更多关于线程暂停的问题，包括何时会发生暂停，以及对未连接的线程和正在执行本地方法的线程，暂停意味着什么。 The address of the Thread comes next, labeled obj. 接下来是 Thread 的地址，标记为 obj。 The address of the Thread* comes next, labeled self. Neither of these addresses is likely to be useful to you unless you’re attaching gdb(1) to a running dalvikvm process. 接下来是 Thread * 的地址，标记为 self。除非你将 gdb(1) 附加到正在运行的 dalvikvm 进程，否则这些地址对你没有用处。 第三行参数说明1sysTid=22299 nice=0 sched=0/0 cgrp=[n/a] handle=-256476304 The kernel’s thread id comes next, labeled sysTid. You can use this if you’re poking around in /proc/pid/task/tid. This is usually the only useful item on this line. 接下来是内核的线程 ID，标记为 sysTid。你可以在 /proc/pid/task/tid 中使用它。这通常是这行对你唯一有用的参数。 The kernel’s nice value for the process comes next, labeled nice. This is as returned by the getpriority(2) system call. 接下来是内核的 nice value，标记为 nice。这是由 getpriority(2) 系统调用返回的。 The pthread scheduler policy and priority come next, labeled sched. This is as returned by the pthread_getschedparam(3) call. 接下来是 pthread 调度程序策略和优先级，标记为 sched。这是由 pthread_getschedparam(3) 调用返回的。 The cgrp is the name of the thread’s scheduler group, pulled from the appropriate cgroup file in /proc. cgrp 是线程调度程序组的名称，从 /proc 中相应的 cgroup 文件中提取。 The pthread_t for the pthread corresponding to this thread comes next, labeled handle. This is not much use unless you’re in gdb(1). 紧接着是与这个线程对应的 pthread 的 pthread_t，标记为 handle。除非你在gdb(1) 中，否则这个用处不大。 第四行参数说明1schedstat=( 153358572 709218 48 ) utm=12 stm=4 core=8 The schedstat data is pulled from the per-process schedstat files in /proc. The format is documented in the Linux kernel tree (Documentation/scheduler/sched-stats.txt): schedstat 数据是从 /proc 中每个进程的 schedstat 文件里面提取的。格式记录在Linux内核树（Documentation/scheduler/sched-stats.txt）中。 1231) time spent on the cpu2) time spent waiting on a runqueue3) # of timeslices run on this cpu If your kernel does not support this, you’ll see “schedstat=( 0 0 0 )”. 如果你的内核不支持这个，你会看到 “schedstat = (0 0 0)”。 The user-mode and kernel-mode jiffies come next, labeled utm and stm. These correspond to the utime and stime fields of the per-thread stat files in /proc. On sufficiently new versions of Dalvik, you’ll also see something like “HZ=100”, so you can double-check that jiffies are the length you expect. These numbers aren’t much use in isolation, except for seeing which threads are taking all the CPU time (if any). 接下来是用户模式和内核模式 jiffies，标记为 utm 和 stm。这些对应于 /proc 中每个线程统计文件的 utime 和 stime 字段。在 Dalvik 的新版本中，你还会看到类似 “HZ = 100” 的内容，因此你可以仔细检查 jiffies 是否是你期望的长度。除了查看哪些线程正在占用所有 CPU 时间（如果有）之外，这些数字并没有太多用处。 The cpu number of the core this thread was last executed on comes next, labeled core. 接下来是最后执行该线程的核心的 CPU 号，标记为 core。 参考文章Understanding Threads and Locks - OracleDifference between core and processor? - stackoverflow","link":"/2018/04/09/translations_How-to-read-Dalvik-SIGQUIT-output/"},{"title":"【译】Deadlocks and ANRs","text":"原文：Deadlocks and ANRs 在本文中，我们将看看如何分析实际的应用程序无响应（ANR）跟踪，确定原因（结果是我们正在使用的某个库中存在死锁）并消除它。我们也将借此机会提供关于理解本文所需的死锁和相关计算机科学主题的简短入门。 关于互斥和死锁的入门我们先看看死锁和互斥是什么。熟悉这部分的人可以跳到 “理解 ANR traces” 部分。 请记住，这并不是要对这个主题进行详尽的处理（这是相当复杂和有趣的），而是为那些刚从大学毕业的人提供一个简短的入门介绍。 什么是互斥在计算机科学中，互斥 mutex（mutual exclustion 的缩写）是一种对象，一次只允许一个线程在代码的关键部分访问共享资源（如文件）。在某些语言中（如 Java），它被称为 Lock，我们将交替使用这些术语。 它通常有两种方法：acquire 和 release（有时称为 lock 和 unlock）。操作系统内核保证一旦一个线程成功获得 lock，在第一个线程释放它之前，其他线程不能获取它。尝试获取 lock 会阻塞第二个线程，直到 lock 再次可用。因此，如果所有线程都确保只在 acquire 和 release 调用之间使用共享资源，那么它们会被保证轮流使用该资源。 互斥的类比为了更好地理解互斥体，设想一个相似的物理世界模式很有帮助。例如，在一些敏捷团队中，习惯使用 “speaking token”（例如球或白板标记）来跟踪谁何时可以发言。只有持有令牌的人才可以发言。当这个人完成时，令牌被放在桌子上，其他人（不一定按顺序）将其拿起并提交他（她）的报告。 互斥体以类似的方式工作：线程类似于团队成员，共享资源是同事关注的，而互斥体则由 “speaking token” 表示。锁定互斥体与拾取令牌相似，而解锁它与将令牌重新放回桌子中间相似。 互斥在行为上的表现让我们考虑两个线程：ThreadA 和 ThreadB 尝试写入日志文件。假设他们正在尝试写入 “Hello world from ThreadA” 和 “Hello world from ThreadB”。 12345678910111213141516171819try { final FileOutputStream fos = new FileOutputStream(File.createTempFile(\"log\", \".txt\")); Runnable r = new Runnable() { @Override public void run() { try { fos.write((\"Hello world from \" + Thread.currentThread().getName()).getBytes()); } catch (IOException e) { e.printStackTrace(); } } }; new Thread(r, \"ThreadA\").start(); new Thread(r, \"ThreadB\").start();} catch (IOException ex) { ex.printStackTrace();} 即使没有同步，大多数情况下这也会产生预期的效果。然而有时候，或许一千次运行才会出现一次，你会看到这样的输出：12Hello worHello world from ThreadB ld from ThreadA 这里发生的是 ThreadB 生成它的输出，而 ThreadA 正在生成它自己的文件，并且文件最终被损坏。解决这个问题的方法是使用一个互斥体（在 Java 中称为 Lock）：123456789101112131415161718192021222324try { final FileOutputStream fos = new FileOutputStream(File.createTempFile(\"log\", \".txt\")); final Lock fileLock = new ReentrantLock(); Runnable r = new Runnable() { @Override public void run() { try { fileLock.lock(); // Thread is now guaranteed exclusive access fos.write((\"Hello world from \" + Thread.currentThread().getName()).getBytes()); fileLock.unlock(); // Thread no longer has exclusive access } catch (IOException e) { e.printStackTrace(); } } }; new Thread(r, \"ThreadA\").start(); new Thread(r, \"ThreadB\").start();} catch (IOException ex) { ex.printStackTrace();} 有了这个补充，就避免了前面描述的情况。在它可以写入文件之前，线程必须获取互斥体（锁），如果两者同时尝试这样做，Android Linux 内核保证只有一个从方法调用返回，而另一个被阻塞直到第一个释放互斥锁。 死锁虽然互斥体在正确使用时功能非常强大，但它们确实有可能导致一个罕见且难以捉摸的问题，称为死锁。这通常发生在两个线程都尝试获取另一个线程所拥有的互斥体时。这导致它们都被永久阻塞住。在 Android 上，如果线程对于运行应用程序是必不可少的（例如，如果其中一个线程是主线程），它很可能会导致 ANR（应用程序无响应）和应用程序崩溃。 死锁是出了名的不得不处理地令人讨厌的问题。造成这种情况的主要原因是非常低的复现率以及缺乏详细记录问题的日志。后一个问题是由于没有抛出错误/异常的事实造成的。唯一的症状是缺乏输出，以及应用程序没有响应任何消息（例如按键，意图广播等），这反过来又导致 Android 系统通过对话框提示用户，询问他或她是否希望杀死应用程序（臭名昭著的ANR）。 死锁的类比在尝试说明死锁时，我们在现实生活的类比显得有点捉襟见肘，但让我们试一试吧。假设小明和小红负责管理对两个共享资源的访问，比如日志文件和数据库连接。小明和小红约定，任何想使用数据库的人都必须持有特定的红色标记，而任何想要访问日志文件的人都必须持有特定的黑色标记。 这很好地运行了一段时间，直到某一刻发生了以下情况： 小明抓住红色标记并开始写入数据库。 小红抓住黑色标记并开始写一些日志。 在仍然保持红色标记的同时，小明也尝试获取黑色标记以写入关于数据库活动的日志。 由于黑色标记不可用，小明停下来等待小红完成它。 在仍然拿着黑色标记的同时，小红也尝试获取红色标记以检查一些数据库活动。 由于红色标记不可用，小红停下来并等待小明完成它。 正如你所看到的，小红和小明现在都拥有其中一个标记，并等待另一个人释放他们的标记。现在无法取得任何进展，活动将永久阻塞。我们遇到了死锁。 解决死锁如果在你的代码当中检测到了这种情况，解决这个问题的方法是改变获取锁的顺序。这种策略有时被称为建立互斥体层次结构。比方说小明和小红为了获得两个标记，约定必须首先抓住红色标记，然后再抓住黑色标记（而不是反过来）。上面的情景会如此展开： 小明抓住红色标记并开始写入数据库。 小红抓住黑色标记并开始写入一些日志。 在仍然保持红色标记的提示，小明也尝试获取黑色标记以写入关于数据库活动的日志。 由于黑色标记不可用，小明停下来等到小红完成它。 小红需要两个标记，但由于上述协议，她首先释放黑色标记。 小红现在尝试获取红色标记，但是由于它不可用，她停下来等待小明完成它。 小明抓住黑色标记（现在可用）并执行他的工作。 小明释放黑色标记 小明释放红色标记。 小红获得现在可用的红色标记。 小红获得黑色标记。 小红执行她的工作。 小红释放黑色标记。 小红释放红色标记。 因此，使用这种规则不可能出现死锁。 处理 ANR如果你的应用程序不幸以 ANR 结束，那么你将不得不使用的唯一东西就是统计数据和 ANR trace。你可能无法重现它，而且你从用户那里得到的反馈在最好的情况下是毫无用处，最坏的情况下是产生误导。 首先，请注意，如果你使用某些第三方报告崩溃的方式（如HockeyApp），你的ANR将不会显示在那里。你必须转到 Google Play 控制台，点击 Crashes &amp; ANRs，并确保将切换按钮设置为 ANR。然后选择表格中显示的问题之一，现在你会看到统计信息和 ANR trace。 首先看看统计数据。这些可以告诉你哪些 Android 版本和手机受到影响，以及问题何时开始（通常是其中一个应用版本）。 然后你必须查看 ANR traces。这些一开始看起来很吓人，但只要耐心一点，你就可以理解它们。 理解 ANR tracesANR trace 与你在各种异常（例如 NullPointerException）中获得的更为熟悉的堆栈跟踪非常相似，但有一些显著的差异： 它在顶部有一个非常大的标题，横跨几行，包含有关该进程的信息。如果你不理解其中的大部分，没有关系，很少有 android 应用程序开发者能做到，而且那里很少有 ANR 的解决方案。 在那里有不止一个堆栈跟踪 - 事实上可以有很多。原因是，与更常见的你的代码在其中一个应用程序线程中抛出异常的情况不同，如果是 ANR，应用程序已停止运行，Android 可以执行的最佳操作是转储所有线程的状态，因为没有办法知道哪一个是有问题的。 由于没有异常抛出，因此没有异常名称存在。 每个线程的顶部都有一个线程头文件，列出了它的名称和状态：1&quot;ReferenceQueueDaemon&quot; daemon prio=5 tid=3 Waiting 很多堆栈跟踪条目是隐藏的，因为它们显示的是 native 的代码：1native: #00 pc 000000000048df54 /system/lib64/libart.so (_ZN3art15DumpNativeStackERNSt3__113basic_ostreamIcNS0_11char_traitsIcEEEEiPKcPNS_9ArtMethodEPv+236) 一般来说，结构是这样的：12345678910111213141516171819202122232425262728293031----- pid 3775 at 2017-03-14 11:28:21 -----Cmd line: .... Build fingerprint: .... ABI: 'x86' ....DALVIK THREADS (16): &quot;thread name&quot; ... Status | group=&quot;main&quot; ... | held mutexes= ... at java.lang.Thread.sleep!(Native method) - sleeping on &lt;0x0c075403&gt; (a java.lang.Object) at java.lang.Thread.sleep(Thread.java:1031) - locked &lt;0x0c075403&gt; (a java.lang.Object) at java.lang.Thread.sleep(Thread.java:985) at ... at ......&quot;thread name2&quot; ... Status | group= ... | held mutexes= ... at java.lang.Thread.sleep!(Native method) - sleeping on &lt;0x0c075403&gt; (a java.lang.Object) at java.lang.Thread.sleep(Thread.java:1031) - locked &lt;0x0c075403&gt; (a java.lang.Object) at java.lang.Thread.sleep(Thread.java:985) at ... at ...... 通常，你需要的信息位于线程条目里，所以追踪 ANR 时尽量关注这些部分。特别注意你的主线程（tid = 1），它是处理 UI 操作的线程。ANR 始终是由于此线程被阻塞或执行太多工作而导致的。 检测死锁trace 中的每个线程条目包含一些可以帮助你检测死锁的提示。首先你可以看到线程的状态：它通常是 Runnable，Sleeping，Waiting，Native 或 Blocked。这告诉你 ANR 发生时线程处于什么状态，这里特别注意那些被标记为 Blocked 状态的线程。 标记为阻塞的线程通常会告诉你他们正在尝试获取的互斥锁（锁）以及持有该锁的线程的线程标识（tid）。然后，你可以向下滚动到列表中与该线程对应的条目，如果你发现该线程被阻塞，则可以查看它尝试获取的互斥锁以及哪个线程正在锁定这个互斥锁。通常这是第一个线程，这意味着你已经检测到了死锁。 让我们来看一个真实的例子（注意：这个 trace 是真实的，但经过了修改，删除所有可识别的信息）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512----- pid 25967 at 2017-03-30 05:32:57 ----- Cmd line: com.example Build fingerprint: ABI: 'arm64' Build type: optimized Zygote loaded classes=4071 post zygote classes=1552 Intern table: 57141 strong; 443 weak JNI: CheckJNI is off; globals=325 (plus 363 weak) Libraries: /data/app/com.google.android.gms-1/lib/arm64/libconscrypt_gmscore_jni.so /data/app/com.google.android.gms-1/lib/arm64/libgmscore.so /system/lib64/libandroid.so /system/lib64/libcompiler_rt.so /system/lib64/libfm_jni.so /system/lib64/libhwdeviceinfo.so /system/lib64/libhwtheme_jni.so /system/lib64/libjavacrypto.so /system/lib64/libjnigraphics.so /system/lib64/libmedia_jni.so /system/lib64/libwebviewchromium_loader.so libjavacore.so (12) Heap: 20% free, 22MB/28MB; 55958 objects Dumping cumulative Gc timings Start Dumping histograms for 1 iterations for partial concurrent mark sweep ProcessMarkStack: Sum: 11.069ms 99% C.I. 0.105ms-10.838ms Avg: 3.689ms Max: 10.839ms MarkRootsCheckpoint: Sum: 5.943ms 99% C.I. 2.735ms-3.208ms Avg: 2.971ms Max: 3.208ms UpdateAndMarkZygoteModUnionTable: Sum: 4.417ms 99% C.I. 4.417ms-4.417ms Avg: 4.417ms Max: 4.417ms UpdateAndMarkImageModUnionTable: Sum: 4.200ms 99% C.I. 4.200ms-4.200ms Avg: 4.200ms Max: 4.200ms MarkConcurrentRoots: Sum: 3.501ms 99% C.I. 0.203ms-3.269ms Avg: 1.750ms Max: 3.298ms SweepMallocSpace: Sum: 2.069ms 99% C.I. 0.040ms-2.029ms Avg: 1.034ms Max: 2.029ms ScanGrayAllocSpaceObjects: Sum: 1.014ms 99% C.I. 4us-1010us Avg: 507us Max: 1010us ReMarkRoots: Sum: 830us 99% C.I. 830us-830us Avg: 830us Max: 830us MarkAllocStackAsLive: Sum: 527us 99% C.I. 527us-527us Avg: 527us Max: 527us (Paused)ScanGrayAllocSpaceObjects: Sum: 497us 99% C.I. 0.500us-495.500us Avg: 248.500us Max: 497usSweepLargeObjects: Sum: 216us 99% C.I. 216us-216us Avg: 216us Max: 216us ImageModUnionClearCards: Sum: 167us 99% C.I. 57us-110us Avg: 83.500us Max: 110us SweepSystemWeaks: Sum: 93us 99% C.I. 93us-93us Avg: 93us Max: 93us AllocSpaceClearCards: Sum: 84us 99% C.I. 1us-55us Avg: 21us Max: 55us FinishPhase: Sum: 81us 99% C.I. 81us-81us Avg: 81us Max: 81us EnqueueFinalizerReferences: Sum: 78us 99% C.I. 78us-78us Avg: 78us Max: 78us MarkNonThreadRoots: Sum: 69us 99% C.I. 31us-38us Avg: 34.500us Max: 38us ScanGrayImageSpaceObjects: Sum: 56us 99% C.I. 56us-56us Avg: 56us Max: 56us (Paused)ScanGrayImageSpaceObjects: Sum: 53us 99% C.I. 53us-53us Avg: 53us Max: 53usZygoteModUnionClearCards: Sum: 35us 99% C.I. 15us-20us Avg: 17.500us Max: 20us RevokeAllThreadLocalAllocationStacks: Sum: 24us 99% C.I. 24us-24us Avg: 24us Max: 24us (Paused)PausePhase: Sum: 20us 99% C.I. 20us-20us Avg: 20us Max: 20us(Paused)ProcessMarkStack: Sum: 18us 99% C.I. 18us-18us Avg: 18us Max: 18usMarkingPhase: Sum: 17us 99% C.I. 17us-17us Avg: 17us Max: 17us ScanGrayZygoteSpaceObjects: Sum: 15us 99% C.I. 15us-15us Avg: 15us Max: 15us ProcessReferences: Sum: 11us 99% C.I. 11us-11us Avg: 11us Max: 11us PreCleanCards: Sum: 10us 99% C.I. 10us-10us Avg: 10us Max: 10us (Paused)ScanGrayZygoteSpaceObjects: Sum: 9us 99% C.I. 9us-9us Avg: 9us Max: 9usProcessCards: Sum: 8us 99% C.I. 4us-4us Avg: 4us Max: 4us MarkRoots: Sum: 6us 99% C.I. 6us-6us Avg: 6us Max: 6us BindBitmaps: Sum: 4us 99% C.I. 4us-4us Avg: 4us Max: 4us RecursiveMark: Sum: 2us 99% C.I. 2us-2us Avg: 2us Max: 2us SweepZygoteSpace: Sum: 1us 99% C.I. 1us-1us Avg: 1us Max: 1us FindDefaultSpaceBitmap: Sum: 0 99% C.I. 0ns-0ns Avg: 0ns Max: 0ns Done Dumping histograms partial concurrent mark sweep paused: Sum: 3.368ms 99% C.I. 3.368ms-3.368ms Avg: 3.368ms Max: 3.368ms partial concurrent mark sweep total time: 35.187ms mean time: 35.187ms partial concurrent mark sweep freed: 9904 objects with total size 1088KB partial concurrent mark sweep throughput: 282971/s / 30MB/s Start Dumping histograms for 1 iterations for sticky concurrent mark sweep FreeList: Sum: 6.592ms 99% C.I. 9us-448.750us Avg: 160.780us Max: 457us SweepSystemWeaks: Sum: 4.712ms 99% C.I. 4.712ms-4.712ms Avg: 4.712ms Max: 4.712ms ProcessMarkStack: Sum: 3.085ms 99% C.I. 0.333us-2990us Avg: 771.250us Max: 3038us MarkConcurrentRoots: Sum: 2.759ms 99% C.I. 0.017ms-2.723ms Avg: 1.379ms Max: 2.742ms MarkRootsCheckpoint: Sum: 2.357ms 99% C.I. 0.699ms-1.658ms Avg: 1.178ms Max: 1.658ms SweepArray: Sum: 2.075ms 99% C.I. 2.075ms-2.075ms Avg: 2.075ms Max: 2.075ms ScanGrayAllocSpaceObjects: Sum: 1.745ms 99% C.I. 0.500us-934us Avg: 436.250us Max: 934us ScanGrayImageSpaceObjects: Sum: 1.419ms 99% C.I. 33us-1386us Avg: 709.500us Max: 1386us ScanGrayZygoteSpaceObjects: Sum: 362us 99% C.I. 6us-356us Avg: 181us Max: 356us ResetStack: Sum: 204us 99% C.I. 204us-204us Avg: 204us Max: 204us MarkingPhase: Sum: 200us 99% C.I. 200us-200us Avg: 200us Max: 200us ReMarkRoots: Sum: 157us 99% C.I. 157us-157us Avg: 157us Max: 157us AllocSpaceClearCards: Sum: 123us 99% C.I. 0.500us-67us Avg: 30.750us Max: 67us (Paused)ScanGrayAllocSpaceObjects: Sum: 68us 99% C.I. 0.500us-68us Avg: 34us Max: 68usMarkNonThreadRoots: Sum: 59us 99% C.I. 24us-35us Avg: 29.500us Max: 35us ZygoteModUnionClearCards: Sum: 46us 99% C.I. 11us-35us Avg: 23us Max: 35us FinishPhase: Sum: 38us 99% C.I. 38us-38us Avg: 38us Max: 38us (Paused)ScanGrayImageSpaceObjects: Sum: 31us 99% C.I. 31us-31us Avg: 31us Max: 31us(Paused)PausePhase: Sum: 30us 99% C.I. 30us-30us Avg: 30us Max: 30usEnqueueFinalizerReferences: Sum: 29us 99% C.I. 29us-29us Avg: 29us Max: 29us ReclaimPhase: Sum: 17us 99% C.I. 17us-17us Avg: 17us Max: 17us InitializePhase: Sum: 14us 99% C.I. 14us-14us Avg: 14us Max: 14us ProcessCards: Sum: 11us 99% C.I. 4us-7us Avg: 5.500us Max: 7us PreCleanCards: Sum: 7us 99% C.I. 7us-7us Avg: 7us Max: 7us (Paused)ScanGrayZygoteSpaceObjects: Sum: 6us 99% C.I. 6us-6us Avg: 6us Max: 6usProcessReferences: Sum: 5us 99% C.I. 5us-5us Avg: 5us Max: 5us MarkRoots: Sum: 4us 99% C.I. 4us-4us Avg: 4us Max: 4us UnBindBitmaps: Sum: 3us 99% C.I. 3us-3us Avg: 3us Max: 3us RecordFree: Sum: 2us 99% C.I. 2us-2us Avg: 2us Max: 2us ForwardSoftReferences: Sum: 1us 99% C.I. 1us-1us Avg: 1us Max: 1us (Paused)ProcessMarkStack: Sum: 0 99% C.I. 0ns-0ns Avg: 0ns Max: 0nsDone Dumping histograms sticky concurrent mark sweep paused: Sum: 1.669ms 99% C.I. 1.669ms-1.669ms Avg: 1.669ms Max: 1.669ms sticky concurrent mark sweep total time: 26.304ms mean time: 26.304ms sticky concurrent mark sweep freed: 40059 objects with total size 2MB sticky concurrent mark sweep throughput: 1.54073e+06/s / 112MB/s Start Dumping histograms for 2 iterations for marksweep + semispace MarkRoots: Sum: 76.622ms 99% C.I. 31.604ms-45.018ms Avg: 38.311ms Max: 45.018ms ProcessMarkStack: Sum: 51.438ms 99% C.I. 0.008ms-30.576ms Avg: 12.859ms Max: 30.576ms ClearCardTable: Sum: 12.596ms 99% C.I. 2.902ms-9.633ms Avg: 6.298ms Max: 9.694ms UpdateAndMarkImageModUnionTable: Sum: 5.851ms 99% C.I. 1.762ms-4.077ms Avg: 2.925ms Max: 4.089ms MarkStackAsLive: Sum: 2.255ms 99% C.I. 0.104ms-2.151ms Avg: 1.127ms Max: 2.151ms UpdateAndMarkZygoteModUnionTable: Sum: 992us 99% C.I. 477us-515us Avg: 496us Max: 515us (Paused)EnqueueFinalizerReferences: Sum: 819us 99% C.I. 51us-768us Avg: 409.500us Max: 768usSweepSystemWeaks: Sum: 570us 99% C.I. 263us-307us Avg: 285us Max: 307us RevokeAllThreadLocalBuffers: Sum: 519us 99% C.I. 65us-193us Avg: 129.750us Max: 193us SweepLargeObjects: Sum: 353us 99% C.I. 25us-328us Avg: 176.500us Max: 328us ImageModUnionClearCards: Sum: 204us 99% C.I. 82us-122us Avg: 102us Max: 122us FinishPhase: Sum: 174us 99% C.I. 58us-116us Avg: 87us Max: 116us SweepAllocSpace: Sum: 105us 99% C.I. 35us-70us Avg: 52.500us Max: 70us (Paused)ProcessReferences: Sum: 43us 99% C.I. 17us-26us Avg: 21.500us Max: 26usSwapBitmaps: Sum: 39us 99% C.I. 16us-23us Avg: 19.500us Max: 23us MarkReachableObjects: Sum: 32us 99% C.I. 14us-18us Avg: 16us Max: 18us BindBitmaps: Sum: 20us 99% C.I. 7us-13us Avg: 10us Max: 13us ProcessCards: Sum: 16us 99% C.I. 5us-11us Avg: 8us Max: 11us Sweep: Sum: 14us 99% C.I. 6us-8us Avg: 7us Max: 8us MarkingPhase: Sum: 10us 99% C.I. 2us-8us Avg: 5us Max: 8us InitializePhase: Sum: 9us 99% C.I. 2us-7us Avg: 4.500us Max: 7us ReclaimPhase: Sum: 7us 99% C.I. 3us-4us Avg: 3.500us Max: 4us PreSweepingGcVerification: Sum: 3us 99% C.I. 1us-2us Avg: 1.500us Max: 2us SweepZygoteSpace: Sum: 2us 99% C.I. 1us-1us Avg: 1us Max: 1us PreGcVerificationPaused: Sum: 1us 99% C.I. 250ns-1000ns Avg: 500ns Max: 1000ns PostGcVerificationPaused: Sum: 0 99% C.I. 0ns-0ns Avg: 0ns Max: 0ns Done Dumping histograms marksweep + semispace paused: Sum: 153.066ms 99% C.I. 71.381ms-81.685ms Avg: 76.533ms Max: 81.685ms marksweep + semispace total time: 152.772ms mean time: 76.386ms marksweep + semispace freed: 85295 objects with total size 4MB marksweep + semispace throughput: 561151/s / 32MB/s Total time spent in GC: 214.263ms Mean GC size throughput: 15MB/s Mean GC object throughput: 233017 objects/s Total number of allocations 105885 Total bytes allocated 26MB Total bytes freed 3MB Free memory 5MB Free memory until GC 5MB Free memory until OOME 233MB Total memory 28MB Max memory 256MB Zygote space size 1540KB Total mutator paused time: 158.103ms Total time waiting for GC to complete: 5.416us Total GC count: 4 Total GC time: 214.263ms Total blocking GC count: 0 Total blocking GC time: 0 Histogram of GC count per 10000 ms: 0:10,1:1,2:1 Histogram of blocking GC count per 10000 ms: 0:12suspend all histogram: Sum: 3.470ms 99% C.I. 1us-1882.560us Avg: 266.923us Max: 1896us DALVIK THREADS (21): &quot;Signal Catcher&quot; daemon prio=5 tid=2 Runnable | group=&quot;system&quot; sCount=0 dsCount=0 obj=0x12c0d0a0 self=0x55999df770 | sysTid=25972 nice=0 cgrp=top_visible sched=0/0 handle=0x7f78de7450 | state=R schedstat=( 6967792 0 10 ) utm=0 stm=0 core=3 HZ=100 | stack=0x7f78ceb000-0x7f78ced000 stackSize=1013KB | held mutexes= &quot;mutator lock&quot;(shared held) native: #00 pc 000000000048df54 /system/lib64/libart.so (_ZN3art15DumpNativeStackERNSt3__113basic_ostreamIcNS0_11char_traitsIcEEEEiPKcPNS_9ArtMethodEPv+236) native: #01 pc 000000000045d404 /system/lib64/libart.so (_ZNK3art6Thread4DumpERNSt3__113basic_ostreamIcNS1_11char_traitsIcEEEE+220) native: #02 pc 0000000000469c70 /system/lib64/libart.so (_ZN3art14DumpCheckpoint3RunEPNS_6ThreadE+688) native: #03 pc 000000000046ab8c /system/lib64/libart.so (_ZN3art10ThreadList13RunCheckpointEPNS_7ClosureE+276) native: #04 pc 000000000046b248 /system/lib64/libart.so (_ZN3art10ThreadList4DumpERNSt3__113basic_ostreamIcNS1_11char_traitsIcEEEE+188) native: #05 pc 000000000046bb2c /system/lib64/libart.so (_ZN3art10ThreadList14DumpForSigQuitERNSt3__113basic_ostreamIcNS1_11char_traitsIcEEEE+492) native: #06 pc 0000000000435064 /system/lib64/libart.so (_ZN3art7Runtime14DumpForSigQuitERNSt3__113basic_ostreamIcNS1_11char_traitsIcEEEE+96) native: #07 pc 000000000044281c /system/lib64/libart.so (_ZN3art13SignalCatcher13HandleSigQuitEv+1256) native: #08 pc 000000000044342c /system/lib64/libart.so (_ZN3art13SignalCatcher3RunEPv+452) native: #09 pc 0000000000068464 /system/lib64/libc.so (_ZL15__pthread_startPv+52) native: #10 pc 000000000001d544 /system/lib64/libc.so (__start_thread+16) (no managed stack frames)&quot;main&quot; prio=5 tid=1 Blocked | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x7477dea0 self=0x5597d71b70 | sysTid=25967 nice=-1 cgrp=top_visible sched=0/0 handle=0x7f7dcb5000 | state=S schedstat=( 688872496 20759648 497 ) utm=57 stm=11 core=0 HZ=100 | stack=0x7fc4bc9000-0x7fc4bcb000 stackSize=8MB | held mutexes= at com.google.android.gms.tagmanager.zzp.zzav(unavailable:-1) - waiting to lock &lt;0x08362446&gt; (a com.google.android.gms.tagmanager.zzp) held by thread 15 at com.google.android.gms.tagmanager.zzp.zza(unavailable:-1) at com.google.android.gms.tagmanager.zzp$zzd.zzOE(unavailable:-1) at com.google.android.gms.tagmanager.zzo.refresh(unavailable:-1) - locked &lt;0x023ef607&gt; (a com.google.android.gms.tagmanager.zzo) at com.example.MyApplication$1.onSuccess(MyApplication.java:176) at com.example.MyApplication$1.onSuccess(MyApplication.java:169) at com.example.callback.GenericCallBack.handleSuccess(GenericCallBack.java:39) at com.example.service.AnalyticsServiceImpl$1.onResult(AnalyticsServiceImpl.java:74) at com.example.service.AnalyticsServiceImpl$1.onResult(AnalyticsServiceImpl.java:65) at com.google.android.gms.internal.zzzx$zza.zzb(unavailable:-1) at com.google.android.gms.internal.zzzx$zza.handleMessage(unavailable:-1) at android.os.Handler.dispatchMessage(Handler.java:102) at android.os.Looper.loop(Looper.java:150) at android.app.ActivityThread.main(ActivityThread.java:5546) at java.lang.reflect.Method.invoke!(Native method) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:794) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:684)&quot;ReferenceQueueDaemon&quot; daemon prio=5 tid=3 Waiting | group=&quot;system&quot; sCount=1 dsCount=0 obj=0x12c0d100 self=0x559992ff30 | sysTid=25973 nice=0 cgrp=top_visible sched=0/0 handle=0x7f78cdf450 | state=S schedstat=( 1998256 1180608 19 ) utm=0 stm=0 core=0 HZ=100 | stack=0x7f78bdd000-0x7f78bdf000 stackSize=1037KB | held mutexes= at java.lang.Object.wait!(Native method) - waiting on &lt;0x042f1334&gt; (a java.lang.Class) at java.lang.Daemons$ReferenceQueueDaemon.run(Daemons.java:147) - locked &lt;0x042f1334&gt; (a java.lang.Class) at java.lang.Thread.run(Thread.java:833)&quot;FinalizerDaemon&quot; daemon prio=5 tid=4 Waiting | group=&quot;system&quot; sCount=1 dsCount=0 obj=0x12c0d160 self=0x5597d6e0d0 | sysTid=25974 nice=0 cgrp=top_visible sched=0/0 handle=0x7f78bd3450 | state=S schedstat=( 9917648 1193088 41 ) utm=0 stm=0 core=1 HZ=100 | stack=0x7f78ad1000-0x7f78ad3000 stackSize=1037KB | held mutexes= at java.lang.Object.wait!(Native method) - waiting on &lt;0x0e1d355d&gt; (a java.lang.ref.ReferenceQueue) at java.lang.Object.wait(Object.java:423) at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:101) - locked &lt;0x0e1d355d&gt; (a java.lang.ref.ReferenceQueue) at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:72) at java.lang.Daemons$FinalizerDaemon.run(Daemons.java:185) at java.lang.Thread.run(Thread.java:833)&quot;HeapTaskDaemon&quot; daemon prio=5 tid=5 Blocked | group=&quot;system&quot; sCount=1 dsCount=0 obj=0x12c0d1c0 self=0x55995bd630 | sysTid=25976 nice=0 cgrp=top_visible sched=0/0 handle=0x7f789c0450 | state=S schedstat=( 209432704 2489136 42 ) utm=19 stm=1 core=4 HZ=100 | stack=0x7f788be000-0x7f788c0000 stackSize=1037KB | held mutexes= kernel: (couldn't read /proc/self/task/25976/stack) native: #00 pc 000000000001a8d4 /system/lib64/libc.so (syscall+28) native: #01 pc 000000000013a02c /system/lib64/libart.so (_ZN3art17ConditionVariable4WaitEPNS_6ThreadE+136) native: #02 pc 000000000026a1f4 /system/lib64/libart.so (_ZN3art2gc13TaskProcessor7GetTaskEPNS_6ThreadE+128) native: #03 pc 000000000026a85c /system/lib64/libart.so (_ZN3art2gc13TaskProcessor11RunAllTasksEPNS_6ThreadE+120) native: #04 pc 000000000000054c /data/dalvik-cache/arm64/system@framework@boot.oat (Java_dalvik_system_VMRuntime_runHeapTasks__+128) at dalvik.system.VMRuntime.runHeapTasks(Native method) - waiting to lock an unknown object at java.lang.Daemons$HeapTaskDaemon.run(Daemons.java:355) at java.lang.Thread.run(Thread.java:833)&quot;FinalizerWatchdogDaemon&quot; daemon prio=5 tid=6 Waiting | group=&quot;system&quot; sCount=1 dsCount=0 obj=0x12c0d220 self=0x559855a550 | sysTid=25975 nice=0 cgrp=top_visible sched=0/0 handle=0x7f78acc450 | state=S schedstat=( 1235520 0 10 ) utm=0 stm=0 core=2 HZ=100 | stack=0x7f789ca000-0x7f789cc000 stackSize=1037KB | held mutexes= at java.lang.Object.wait!(Native method) - waiting on &lt;0x0ba03ed2&gt; (a java.lang.Daemons$FinalizerWatchdogDaemon) at java.lang.Daemons$FinalizerWatchdogDaemon.waitForObject(Daemons.java:255) - locked &lt;0x0ba03ed2&gt; (a java.lang.Daemons$FinalizerWatchdogDaemon) at java.lang.Daemons$FinalizerWatchdogDaemon.run(Daemons.java:227) at java.lang.Thread.run(Thread.java:833)&quot;Binder_1&quot; prio=5 tid=7 Native | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x12c0d280 self=0x5599938310 | sysTid=25977 nice=0 cgrp=top_visible sched=0/0 handle=0x7f63b1e450 | state=S schedstat=( 6009328 2418208 23 ) utm=0 stm=0 core=3 HZ=100 | stack=0x7f63a22000-0x7f63a24000 stackSize=1013KB | held mutexes= kernel: (couldn't read /proc/self/task/25977/stack) native: #00 pc 000000000006af08 /system/lib64/libc.so (__ioctl+4) native: #01 pc 0000000000074a00 /system/lib64/libc.so (ioctl+100) native: #02 pc 000000000002d494 /system/lib64/libbinder.so (_ZN7android14IPCThreadState14talkWithDriverEb+164) native: #03 pc 000000000002dce8 /system/lib64/libbinder.so (_ZN7android14IPCThreadState20getAndExecuteCommandEv+24) native: #04 pc 000000000002de04 /system/lib64/libbinder.so (_ZN7android14IPCThreadState14joinThreadPoolEb+76) native: #05 pc 0000000000036858 /system/lib64/libbinder.so (???) native: #06 pc 0000000000016394 /system/lib64/libutils.so (_ZN7android6Thread11_threadLoopEPv+208) native: #07 pc 0000000000092bf0 /system/lib64/libandroid_runtime.so (_ZN7android14AndroidRuntime15javaThreadShellEPv+96) native: #08 pc 0000000000015be4 /system/lib64/libutils.so (???) native: #09 pc 0000000000068464 /system/lib64/libc.so (_ZL15__pthread_startPv+52) native: #10 pc 000000000001d544 /system/lib64/libc.so (__start_thread+16) (no managed stack frames)&quot;Binder_2&quot; prio=5 tid=8 Native | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x12c0d2e0 self=0x5599935b10 | sysTid=25978 nice=0 cgrp=top_visible sched=0/0 handle=0x7f63a1f450 | state=S schedstat=( 5317520 869440 23 ) utm=0 stm=0 core=1 HZ=100 | stack=0x7f63923000-0x7f63925000 stackSize=1013KB | held mutexes= kernel: (couldn't read /proc/self/task/25978/stack) native: #00 pc 000000000006af08 /system/lib64/libc.so (__ioctl+4) native: #01 pc 0000000000074a00 /system/lib64/libc.so (ioctl+100) native: #02 pc 000000000002d494 /system/lib64/libbinder.so (_ZN7android14IPCThreadState14talkWithDriverEb+164) native: #03 pc 000000000002dce8 /system/lib64/libbinder.so (_ZN7android14IPCThreadState20getAndExecuteCommandEv+24) native: #04 pc 000000000002de04 /system/lib64/libbinder.so (_ZN7android14IPCThreadState14joinThreadPoolEb+76) native: #05 pc 0000000000036858 /system/lib64/libbinder.so (???) native: #06 pc 0000000000016394 /system/lib64/libutils.so (_ZN7android6Thread11_threadLoopEPv+208) native: #07 pc 0000000000092bf0 /system/lib64/libandroid_runtime.so (_ZN7android14AndroidRuntime15javaThreadShellEPv+96) native: #08 pc 0000000000015be4 /system/lib64/libutils.so (???) native: #09 pc 0000000000068464 /system/lib64/libc.so (_ZL15__pthread_startPv+52) native: #10 pc 000000000001d544 /system/lib64/libc.so (__start_thread+16) (no managed stack frames)&quot;pool-5-thread-1&quot; prio=5 tid=11 Waiting | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x12c0d340 self=0x5598b73790 | sysTid=26000 nice=0 cgrp=top_visible sched=0/0 handle=0x7f61cf6450 | state=S schedstat=( 15990624 1283568 26 ) utm=1 stm=0 core=2 HZ=100 | stack=0x7f61bf4000-0x7f61bf6000 stackSize=1037KB | held mutexes= at java.lang.Object.wait!(Native method) - waiting on &lt;0x0ecaeba3&gt; (a java.lang.Object) at java.lang.Thread.parkFor$(Thread.java:1235) - locked &lt;0x0ecaeba3&gt; (a java.lang.Object) at sun.misc.Unsafe.park(Unsafe.java:299) at java.util.concurrent.locks.LockSupport.park(LockSupport.java:158) at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2013) at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:410) at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1036) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1098) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:588) at java.lang.Thread.run(Thread.java:833)&quot;pool-6-thread-1&quot; prio=5 tid=12 Waiting | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x12c0d3a0 self=0x55999908b0 | sysTid=26001 nice=0 cgrp=top_visible sched=0/0 handle=0x7f61bf1450 | state=S schedstat=( 13138944 1240720 14 ) utm=1 stm=0 core=6 HZ=100 | stack=0x7f61aef000-0x7f61af1000 stackSize=1037KB | held mutexes= at java.lang.Object.wait!(Native method) - waiting on &lt;0x03442ea0&gt; (a java.lang.Object) at java.lang.Thread.parkFor$(Thread.java:1235) - locked &lt;0x03442ea0&gt; (a java.lang.Object) at sun.misc.Unsafe.park(Unsafe.java:299) at java.util.concurrent.locks.LockSupport.park(LockSupport.java:158) at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2013) at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:410) at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1036) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1098) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:588) at java.lang.Thread.run(Thread.java:833)&quot;Thread-1658&quot; prio=5 tid=13 TimedWaiting | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x12c0d400 self=0x5598ca44c0 | sysTid=26002 nice=10 cgrp=top_visible sched=0/0 handle=0x7f61aec450 | state=S schedstat=( 18796336 3701568 40 ) utm=1 stm=0 core=2 HZ=100 | stack=0x7f619ea000-0x7f619ec000 stackSize=1037KB | held mutexes= at java.lang.Object.wait!(Native method) - waiting on &lt;0x09fcca59&gt; (a java.lang.Object) at java.lang.Object.wait(Object.java:423) at com.google.android.gms.tagmanager.zza.zzOu(unavailable:-1) - locked &lt;0x09fcca59&gt; (a java.lang.Object) at com.google.android.gms.tagmanager.zza.zzb(unavailable:-1) at com.google.android.gms.tagmanager.zza$2.run(unavailable:-1) at java.lang.Thread.run(Thread.java:833)&quot;pool-7-thread-1&quot; prio=5 tid=14 Waiting | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x12c0d460 self=0x55985c4f50 | sysTid=26005 nice=0 cgrp=top_visible sched=0/0 handle=0x7f6174b450 | state=S schedstat=( 12652016 149760 18 ) utm=1 stm=0 core=3 HZ=100 | stack=0x7f61649000-0x7f6164b000 stackSize=1037KB | held mutexes= at java.lang.Object.wait!(Native method) - waiting on &lt;0x001f761e&gt; (a java.lang.Object) at java.lang.Thread.parkFor$(Thread.java:1235) - locked &lt;0x001f761e&gt; (a java.lang.Object) at sun.misc.Unsafe.park(Unsafe.java:299) at java.util.concurrent.locks.LockSupport.park(LockSupport.java:158) at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2013) at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:410) at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1036) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1098) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:588) at java.lang.Thread.run(Thread.java:833)&quot;pool-8-thread-1&quot; prio=5 tid=15 Blocked | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x12c0d4c0 self=0x5598cd6440 | sysTid=26006 nice=0 cgrp=top_visible sched=0/0 handle=0x7f61646450 | state=S schedstat=( 64174864 5461664 62 ) utm=6 stm=0 core=3 HZ=100 | stack=0x7f61544000-0x7f61546000 stackSize=1037KB | held mutexes= at com.google.android.gms.tagmanager.zzo.zza(unavailable:-1) - waiting to lock &lt;0x023ef607&gt; (a com.google.android.gms.tagmanager.zzo) held by thread 1 at com.google.android.gms.tagmanager.zzp.zza(unavailable:-1) - locked &lt;0x08362446&gt; (a com.google.android.gms.tagmanager.zzp) at com.google.android.gms.tagmanager.zzp.zza(unavailable:-1) at com.google.android.gms.tagmanager.zzp$zzc.zzb(unavailable:-1) - locked &lt;0x08362446&gt; (a com.google.android.gms.tagmanager.zzp) at com.google.android.gms.tagmanager.zzp$zzc.onSuccess(unavailable:-1) at com.google.android.gms.tagmanager.zzct.zzPD(unavailable:-1) at com.google.android.gms.tagmanager.zzct.run(unavailable:-1) at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:423) at java.util.concurrent.FutureTask.run(FutureTask.java:237) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:154) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:269) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1113) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:588) at java.lang.Thread.run(Thread.java:833)&quot;WonderPush&quot; prio=5 tid=16 Native | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x12c0d520 self=0x5598c83520 | sysTid=26007 nice=0 cgrp=top_visible sched=0/0 handle=0x7f61541450 | state=S schedstat=( 86143824 20670208 187 ) utm=8 stm=0 core=0 HZ=100 | stack=0x7f6143f000-0x7f61441000 stackSize=1037KB | held mutexes= kernel: (couldn't read /proc/self/task/26007/stack) native: #00 pc 000000000006b674 /system/lib64/libc.so (__epoll_pwait+8) native: #01 pc 000000000001dba4 /system/lib64/libc.so (epoll_pwait+32) native: #02 pc 000000000001b96c /system/lib64/libutils.so (_ZN7android6Looper9pollInnerEi+144) native: #03 pc 000000000001bd4c /system/lib64/libutils.so (_ZN7android6Looper8pollOnceEiPiS1_PPv+80) native: #04 pc 00000000000d7e2c /system/lib64/libandroid_runtime.so (_ZN7android18NativeMessageQueue8pollOnceEP7_JNIEnvP8_jobjecti+48) native: #05 pc 000000000000082c /data/dalvik-cache/arm64/system@framework@boot.oat (Java_android_os_MessageQueue_nativePollOnce__JI+144) at android.os.MessageQueue.nativePollOnce(Native method) at android.os.MessageQueue.next(MessageQueue.java:330) at android.os.Looper.loop(Looper.java:137) at com.wonderpush.sdk.WonderPush$1.run(WonderPush.java:67) at java.lang.Thread.run(Thread.java:833)&quot;Thread-1663&quot; prio=5 tid=17 Sleeping | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x12c0d580 self=0x5598c95130 | sysTid=26009 nice=0 cgrp=top_visible sched=0/0 handle=0x7f6143c450 | state=S schedstat=( 2586896 703248 4 ) utm=0 stm=0 core=2 HZ=100 | stack=0x7f6133a000-0x7f6133c000 stackSize=1037KB | held mutexes= at java.lang.Thread.sleep!(Native method) - sleeping on &lt;0x0c969eff&gt; (a java.lang.Object) at java.lang.Thread.sleep(Thread.java:1046) - locked &lt;0x0c969eff&gt; (a java.lang.Object) at java.lang.Thread.sleep(Thread.java:1000) at com.wonderpush.sdk.WonderPushRequestVault$1.run(WonderPushRequestVault.java:78) at java.lang.Thread.run(Thread.java:833)&quot;Okio Watchdog&quot; daemon prio=5 tid=18 Waiting | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x12c0d5e0 self=0x55999f4a50 | sysTid=26014 nice=0 cgrp=top_visible sched=0/0 handle=0x7f59452450 | state=S schedstat=( 590928 0 4 ) utm=0 stm=0 core=3 HZ=100 | stack=0x7f59350000-0x7f59352000 stackSize=1037KB | held mutexes= at java.lang.Object.wait!(Native method) - waiting on &lt;0x08cd94cc&gt; (a java.lang.Class) at com.android.okhttp.okio.AsyncTimeout.awaitTimeout(AsyncTimeout.java:311) - locked &lt;0x08cd94cc&gt; (a java.lang.Class) at com.android.okhttp.okio.AsyncTimeout.access$000(AsyncTimeout.java:40) at com.android.okhttp.okio.AsyncTimeout$Watchdog.run(AsyncTimeout.java:286)&quot;OkHttp ConnectionPool&quot; daemon prio=5 tid=19 TimedWaiting | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x12c0d640 self=0x5599b2edb0 | sysTid=26016 nice=0 cgrp=top_visible sched=0/0 handle=0x7f5934d450 | state=S schedstat=( 455936 0 3 ) utm=0 stm=0 core=1 HZ=100 | stack=0x7f5924b000-0x7f5924d000 stackSize=1037KB | held mutexes= at java.lang.Object.wait!(Native method) - waiting on &lt;0x04a6b315&gt; (a com.android.okhttp.ConnectionPool) at com.android.okhttp.ConnectionPool.performCleanup(ConnectionPool.java:305) - locked &lt;0x04a6b315&gt; (a com.android.okhttp.ConnectionPool) at com.android.okhttp.ConnectionPool.runCleanupUntilPoolIsEmpty(ConnectionPool.java:242) at com.android.okhttp.ConnectionPool.access$000(ConnectionPool.java:54) at com.android.okhttp.ConnectionPool$1.run(ConnectionPool.java:97) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1113) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:588) at java.lang.Thread.run(Thread.java:833)&quot;RenderThread&quot; prio=5 tid=20 Native | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x12c0d6a0 self=0x5599ba3900 | sysTid=26017 nice=-4 cgrp=top_visible sched=0/0 handle=0x7f59248450 | state=S schedstat=( 2012608 2358720 12 ) utm=0 stm=0 core=3 HZ=100 | stack=0x7f5914c000-0x7f5914e000 stackSize=1013KB | held mutexes= kernel: (couldn't read /proc/self/task/26017/stack) native: #00 pc 000000000006b674 /system/lib64/libc.so (__epoll_pwait+8) native: #01 pc 000000000001dba4 /system/lib64/libc.so (epoll_pwait+32) native: #02 pc 000000000001b96c /system/lib64/libutils.so (_ZN7android6Looper9pollInnerEi+144) native: #03 pc 000000000001bd4c /system/lib64/libutils.so (_ZN7android6Looper8pollOnceEiPiS1_PPv+80) native: #04 pc 000000000002c420 /system/lib64/libhwui.so (_ZN7android10uirenderer12renderthread12RenderThread10threadLoopEv+100) native: #05 pc 0000000000016394 /system/lib64/libutils.so (_ZN7android6Thread11_threadLoopEPv+208) native: #06 pc 0000000000092bf0 /system/lib64/libandroid_runtime.so (_ZN7android14AndroidRuntime15javaThreadShellEPv+96) native: #07 pc 0000000000015be4 /system/lib64/libutils.so (???) native: #08 pc 0000000000068464 /system/lib64/libc.so (_ZL15__pthread_startPv+52) native: #09 pc 000000000001d544 /system/lib64/libc.so (__start_thread+16) (no managed stack frames)&quot;Okio Watchdog&quot; daemon prio=5 tid=21 Waiting | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x12c0d700 self=0x559852e380 | sysTid=26018 nice=0 cgrp=top_visible sched=0/0 handle=0x7f5823f450 | state=S schedstat=( 833040 194480 5 ) utm=0 stm=0 core=0 HZ=100 | stack=0x7f5813d000-0x7f5813f000 stackSize=1037KB | held mutexes= at java.lang.Object.wait!(Native method) - waiting on &lt;0x0cc8d62a&gt; (a java.lang.Class) at okio.AsyncTimeout.awaitTimeout(AsyncTimeout.java:311) - locked &lt;0x0cc8d62a&gt; (a java.lang.Class) at okio.AsyncTimeout.access$000(AsyncTimeout.java:40) at okio.AsyncTimeout$Watchdog.run(AsyncTimeout.java:286)&quot;IntentService[WonderPushRegistrationIntentService]&quot; prio=5 tid=22 Native | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x12c0d760 self=0x5599b3b010 | sysTid=26019 nice=0 cgrp=top_visible sched=0/0 handle=0x7f5813a450 | state=S schedstat=( 4619888 974688 10 ) utm=0 stm=0 core=4 HZ=100 | stack=0x7f58038000-0x7f5803a000 stackSize=1037KB | held mutexes= kernel: (couldn't read /proc/self/task/26019/stack) native: #00 pc 000000000006b674 /system/lib64/libc.so (__epoll_pwait+8) native: #01 pc 000000000001dba4 /system/lib64/libc.so (epoll_pwait+32) native: #02 pc 000000000001b96c /system/lib64/libutils.so (_ZN7android6Looper9pollInnerEi+144) native: #03 pc 000000000001bd4c /system/lib64/libutils.so (_ZN7android6Looper8pollOnceEiPiS1_PPv+80) native: #04 pc 00000000000d7e2c /system/lib64/libandroid_runtime.so (_ZN7android18NativeMessageQueue8pollOnceEP7_JNIEnvP8_jobjecti+48) native: #05 pc 000000000000082c /data/dalvik-cache/arm64/system@framework@boot.oat (Java_android_os_MessageQueue_nativePollOnce__JI+144) at android.os.MessageQueue.nativePollOnce(Native method) at android.os.MessageQueue.next(MessageQueue.java:330) at android.os.Looper.loop(Looper.java:137) at android.os.HandlerThread.run(HandlerThread.java:61)&quot;OkHttp ConnectionPool&quot; daemon prio=5 tid=23 TimedWaiting | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x12c0d7c0 self=0x5599bbd9e0 | sysTid=26021 nice=0 cgrp=top_visible sched=0/0 handle=0x7f58035450 | state=S schedstat=( 798928 0 2 ) utm=0 stm=0 core=3 HZ=100 | stack=0x7f57f33000-0x7f57f35000 stackSize=1037KB | held mutexes= at java.lang.Object.wait!(Native method) - waiting on &lt;0x01402c1b&gt; (a com.squareup.okhttp.ConnectionPool) at com.squareup.okhttp.ConnectionPool.performCleanup(ConnectionPool.java:305) - locked &lt;0x01402c1b&gt; (a com.squareup.okhttp.ConnectionPool) at com.squareup.okhttp.ConnectionPool.runCleanupUntilPoolIsEmpty(ConnectionPool.java:242) at com.squareup.okhttp.ConnectionPool.access$000(ConnectionPool.java:54) at com.squareup.okhttp.ConnectionPool$1.run(ConnectionPool.java:97) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1113) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:588) at java.lang.Thread.run(Thread.java:833)----- end 25967 ----- 这看起来很吓人，不是吗？但是我们现在还不应该放弃，我们 Android 开发人员都是铁打的 :) 我们先看看“主”线程：12345678910111213141516171819202122232425&quot;main&quot; prio=5 tid=1 Blocked | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x7477dea0 self=0x5597d71b70 | sysTid=25967 nice=-1 cgrp=top_visible sched=0/0 handle=0x7f7dcb5000 | state=S schedstat=( 688872496 20759648 497 ) utm=57 stm=11 core=0 HZ=100 | stack=0x7fc4bc9000-0x7fc4bcb000 stackSize=8MB | held mutexes= at com.google.android.gms.tagmanager.zzp.zzav(unavailable:-1) - waiting to lock &lt;0x08362446&gt; (a com.google.android.gms.tagmanager.zzp) held by thread 15 at com.google.android.gms.tagmanager.zzp.zza(unavailable:-1) at com.google.android.gms.tagmanager.zzp$zzd.zzOE(unavailable:-1) at com.google.android.gms.tagmanager.zzo.refresh(unavailable:-1) - locked &lt;0x023ef607&gt; (a com.google.android.gms.tagmanager.zzo) at com.example.MyApplication$1.onSuccess(MyApplication.java:176) at com.example.MyApplication$1.onSuccess(MyApplication.java:169) at com.example.callback.GenericCallBack.handleSuccess(GenericCallBack.java:39) at com.example.service.AnalyticsServiceImpl$1.onResult(AnalyticsServiceImpl.java:74) at com.example.service.AnalyticsServiceImpl$1.onResult(AnalyticsServiceImpl.java:65) at com.google.android.gms.internal.zzzx$zza.zzb(unavailable:-1) at com.google.android.gms.internal.zzzx$zza.handleMessage(unavailable:-1) at android.os.Handler.dispatchMessage(Handler.java:102) at android.os.Looper.loop(Looper.java:150) at android.app.ActivityThread.main(ActivityThread.java:5546) at java.lang.reflect.Method.invoke!(Native method) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:794) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:684) 第一行告诉我们主线程确实被阻塞了，向下滚动一点，我们可以看到直接原因：Google Tagmanager 库中的一行尝试获取线程15所持有的锁：12at com.google.android.gms.tagmanager.zzp.zzav(unavailable:-1)- waiting to lock &lt;0x08362446&gt; (a com.google.android.gms.tagmanager.zzp) held by thread 15 由于 Google Tagmanager 库被混淆了（从所有 zzp 和 zzav 名称可知），所以问题的确切行数和锁的名称是未知的。但该行仍然指向链中的下一个罪魁祸首：ID 为15的线程。 现在让我们在 trace 中搜索线程15：1234567891011121314151617181920212223&quot;pool-8-thread-1&quot; prio=5 tid=15 Blocked | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x12c0d4c0 self=0x5598cd6440 | sysTid=26006 nice=0 cgrp=top_visible sched=0/0 handle=0x7f61646450 | state=S schedstat=( 64174864 5461664 62 ) utm=6 stm=0 core=3 HZ=100 | stack=0x7f61544000-0x7f61546000 stackSize=1037KB | held mutexes= at com.google.android.gms.tagmanager.zzo.zza(unavailable:-1) - waiting to lock &lt;0x023ef607&gt; (a com.google.android.gms.tagmanager.zzo) held by thread 1 at com.google.android.gms.tagmanager.zzp.zza(unavailable:-1) - locked &lt;0x08362446&gt; (a com.google.android.gms.tagmanager.zzp) at com.google.android.gms.tagmanager.zzp.zza(unavailable:-1) at com.google.android.gms.tagmanager.zzp$zzc.zzb(unavailable:-1) - locked &lt;0x08362446&gt; (a com.google.android.gms.tagmanager.zzp) at com.google.android.gms.tagmanager.zzp$zzc.onSuccess(unavailable:-1) at com.google.android.gms.tagmanager.zzct.zzPD(unavailable:-1) at com.google.android.gms.tagmanager.zzct.run(unavailable:-1) at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:423) at java.util.concurrent.FutureTask.run(FutureTask.java:237) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:154) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:269) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1113) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:588) at java.lang.Thread.run(Thread.java:833) 第一行再次告诉我们线程被阻塞，那么我们就来看看造成阻塞的原因：12at com.google.android.gms.tagmanager.zzo.zza(unavailable:-1)- waiting to lock &lt;0x023ef607&gt; (a com.google.android.gms.tagmanager.zzo) held by thread 1 我们看到这个线程正在等待由线程1（主线程）持有的另一个互斥体（称为 com.google.android.gms.tagmanager.zzo）。因此，我们看到线程1正在等待线程15，而线程15正在等待线程1。我们发现了死锁。 解决死锁查看线程15的堆栈跟踪，发现它根本没有通过我们的代码。通过跟踪 trace（注意名称，例如 ThreadPoolExecutor，FutureTask.run() 和 onSuccess），我们可以提出一个有根据的猜测，这是内部回调的一部分，当后端调用成功返回时运行，但遗憾的是我们无法确切地知道，因为库不是开源的（Boo，Google！）。 看看主线程堆栈，尽管我们看到我们确实通过了自己的代码：12345at com.google.android.gms.tagmanager.zzo.refresh(unavailable:-1) - locked &lt;0x023ef607&gt; (a com.google.android.gms.tagmanager.zzo) at com.example.MyApplication$1.onSuccess(MyApplication.java:176) at com.example.MyApplication$1.onSuccess(MyApplication.java:169) at com.example.callback.GenericCallBack.handleSuccess(GenericCallBack.java:39) 让我们快速浏览一下有问题的代码：123456789101112131415161718private void loadGTMContainer() { mAnalyticsService.loadGTMContainer(new GenericCallBack&lt;ContainerHolder&gt;() { @Override public void onSuccess(ContainerHolder result) { if (result != null) { LOGGER.debug(\"Google Tag Manager container loaded successfully\"); //manually refresh the container, just in case result.refresh(); //... } } @Override public void onError(Exception e) { //... } });} 堆栈似乎表明死锁发生在 result.refresh() 内部，事实上，上面的行（和上面的注释）似乎是可疑的。看起来刷新行是可选的（并导致 GTM 内部的问题），所以很有可能删除它也会消除死锁。但是如果不能可靠地重现错误，则无法确定。 现在是时候对 “Google 跟踪代码管理器”，“死锁” 和 “刷新” 这个主题进行一些研究了。迟早你会从谷歌自己的论坛中找到这个链接。在那个发布于2014年的晦涩难懂的论坛帖子中，你可以找到 GTM 库的一位开发人员，他承认在下列情况时会存在错误: 应用程序中的代码可能正在调用容器上的刷新，同时它正在保存从网络中检索到的容器的最新版本。[…] 减少死锁几率的一种方法是避免在初始加载期间调用刷新，以及在自动刷新发生时的时间间隔。入门文档没有详细说明，但容器会按照每隔12小时的间隔自动刷新。[…] 我们将在未来的版本中解决这个死锁。 正如经常发生的那样，未来版本的修复甚至在3年后都没有发生，我不会因为它在近期内可能到来而屏住呼吸。但是，似乎确实是这样的，refresh() 调用确实是无用的，并且它可能是罪魁祸首。 接下来的步骤是删除该行，对 GTM 库功能进行完整的回归测试，然后发布新版本，密切关注统计数据，我们希望看到 ANR 数量急剧下降。 如果你不幸无法找到一些关于你具体情况的论坛主题呢？那么这个问题就很复杂了，但是至少知道你有几个解决罪魁祸首的途径。 如果在互联网上搜索解决方案不会产生结果，我会尝试以下操作（或多或少按此顺序）： 用我现有的证据在库的官方论坛上发布一个主题 在 StackOverflow 上咨询（并在这个问题上给予赏金） 尝试重写有问题的代码 如果一切都不可行，请使用可替选的方案代替有问题的库（例如在本例中使用 Firebase） 结论在这篇文章中，我尝试阐明 ANR 和死锁的一些点，并向你展示如何在分析它们并找到它们的最终原因方面获得一些指引。我们已经看了它们是什么以及它们如何运作，我们也介绍了一个如何解决这个问题的示例。希望这将在未来对你有用。","link":"/2018/04/26/translations-Deadlocks-and-ANRs/"}],"tags":[{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Custom View","slug":"Custom-View","link":"/tags/Custom-View/"},{"name":"Combine Component","slug":"Combine-Component","link":"/tags/Combine-Component/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Nested Classes","slug":"Nested-Classes","link":"/tags/Nested-Classes/"},{"name":"Service","slug":"Service","link":"/tags/Service/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"Localization","slug":"Localization","link":"/tags/Localization/"},{"name":"xliff","slug":"xliff","link":"/tags/xliff/"},{"name":"Git","slug":"Git","link":"/tags/Git/"}],"categories":[{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"Localization","slug":"Android/Localization","link":"/categories/Android/Localization/"}]}